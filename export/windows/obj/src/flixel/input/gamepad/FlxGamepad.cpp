// Generated by Haxe 4.3.6
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxAnalogToDigitalMode
#include <flixel/input/gamepad/FlxAnalogToDigitalMode.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepad
#include <flixel/input/gamepad/FlxGamepad.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadAttachment
#include <flixel/input/gamepad/FlxGamepadAttachment.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadButton
#include <flixel/input/gamepad/FlxGamepadButton.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadDeadZoneMode
#include <flixel/input/gamepad/FlxGamepadDeadZoneMode.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadManager
#include <flixel/input/gamepad/FlxGamepadManager.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadMappedInput
#include <flixel/input/gamepad/FlxGamepadMappedInput.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadModel
#include <flixel/input/gamepad/FlxGamepadModel.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxTypedGamepadAnalogStick
#include <flixel/input/gamepad/FlxTypedGamepadAnalogStick.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_lists_FlxBaseGamepadList
#include <flixel/input/gamepad/lists/FlxBaseGamepadList.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_lists_FlxGamepadAnalogList
#include <flixel/input/gamepad/lists/FlxGamepadAnalogList.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_lists_FlxGamepadButtonList
#include <flixel/input/gamepad/lists/FlxGamepadButtonList.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_lists_FlxGamepadMotionValueList
#include <flixel/input/gamepad/lists/FlxGamepadMotionValueList.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_lists_FlxGamepadPointerValueList
#include <flixel/input/gamepad/lists/FlxGamepadPointerValueList.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_FlxTypedGamepadMapping
#include <flixel/input/gamepad/mappings/FlxTypedGamepadMapping.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_LogitechMapping
#include <flixel/input/gamepad/mappings/LogitechMapping.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_MFiMapping
#include <flixel/input/gamepad/mappings/MFiMapping.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_MayflashWiiRemoteMapping
#include <flixel/input/gamepad/mappings/MayflashWiiRemoteMapping.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_OUYAMapping
#include <flixel/input/gamepad/mappings/OUYAMapping.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_PS4Mapping
#include <flixel/input/gamepad/mappings/PS4Mapping.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_PSVitaMapping
#include <flixel/input/gamepad/mappings/PSVitaMapping.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_SwitchJoyconLeftMapping
#include <flixel/input/gamepad/mappings/SwitchJoyconLeftMapping.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_SwitchJoyconRightMapping
#include <flixel/input/gamepad/mappings/SwitchJoyconRightMapping.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_SwitchProMapping
#include <flixel/input/gamepad/mappings/SwitchProMapping.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_WiiRemoteMapping
#include <flixel/input/gamepad/mappings/WiiRemoteMapping.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_XInputMapping
#include <flixel/input/gamepad/mappings/XInputMapping.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool
#include <flixel/util/FlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_FlxStringUtil
#include <flixel/util/FlxStringUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util_LabelValuePair
#include <flixel/util/LabelValuePair.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_ui_GameInputControl
#include <openfl/ui/GameInputControl.h>
#endif
#ifndef INCLUDED_openfl_ui_GameInputDevice
#include <openfl/ui/GameInputDevice.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_0a9014dd1064fc14_33_new,"flixel.input.gamepad.FlxGamepad","new",0x48c92544,"flixel.input.gamepad.FlxGamepad.new","flixel/input/gamepad/FlxGamepad.hx",33,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_175_getButton,"flixel.input.gamepad.FlxGamepad","getButton",0xf881030c,"flixel.input.gamepad.FlxGamepad.getButton","flixel/input/gamepad/FlxGamepad.hx",175,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_190_applyAxisFlip,"flixel.input.gamepad.FlxGamepad","applyAxisFlip",0xd984f960,"flixel.input.gamepad.FlxGamepad.applyAxisFlip","flixel/input/gamepad/FlxGamepad.hx",190,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_200_update,"flixel.input.gamepad.FlxGamepad","update",0x525157a5,"flixel.input.gamepad.FlxGamepad.update","flixel/input/gamepad/FlxGamepad.hx",200,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_266_reset,"flixel.input.gamepad.FlxGamepad","reset",0x36e79fb3,"flixel.input.gamepad.FlxGamepad.reset","flixel/input/gamepad/FlxGamepad.hx",266,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_289_destroy,"flixel.input.gamepad.FlxGamepad","destroy",0x3b91c3de,"flixel.input.gamepad.FlxGamepad.destroy","flixel/input/gamepad/FlxGamepad.hx",289,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_314_checkStatus,"flixel.input.gamepad.FlxGamepad","checkStatus",0x42f892fe,"flixel.input.gamepad.FlxGamepad.checkStatus","flixel/input/gamepad/FlxGamepad.hx",314,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_330_checkStatusRaw,"flixel.input.gamepad.FlxGamepad","checkStatusRaw",0x11516d8a,"flixel.input.gamepad.FlxGamepad.checkStatusRaw","flixel/input/gamepad/FlxGamepad.hx",330,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_343_checkButtonArrayState,"flixel.input.gamepad.FlxGamepad","checkButtonArrayState",0x928c7916,"flixel.input.gamepad.FlxGamepad.checkButtonArrayState","flixel/input/gamepad/FlxGamepad.hx",343,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_366_checkButtonArrayStateRaw,"flixel.input.gamepad.FlxGamepad","checkButtonArrayStateRaw",0x968e6672,"flixel.input.gamepad.FlxGamepad.checkButtonArrayStateRaw","flixel/input/gamepad/FlxGamepad.hx",366,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_389_anyPressed,"flixel.input.gamepad.FlxGamepad","anyPressed",0xee8d44b2,"flixel.input.gamepad.FlxGamepad.anyPressed","flixel/input/gamepad/FlxGamepad.hx",389,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_400_anyPressedRaw,"flixel.input.gamepad.FlxGamepad","anyPressedRaw",0x4ffbc456,"flixel.input.gamepad.FlxGamepad.anyPressedRaw","flixel/input/gamepad/FlxGamepad.hx",400,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_411_anyJustPressed,"flixel.input.gamepad.FlxGamepad","anyJustPressed",0xd6d7c7e6,"flixel.input.gamepad.FlxGamepad.anyJustPressed","flixel/input/gamepad/FlxGamepad.hx",411,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_422_anyJustPressedRaw,"flixel.input.gamepad.FlxGamepad","anyJustPressedRaw",0xeb4439a2,"flixel.input.gamepad.FlxGamepad.anyJustPressedRaw","flixel/input/gamepad/FlxGamepad.hx",422,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_433_anyJustReleased,"flixel.input.gamepad.FlxGamepad","anyJustReleased",0x2ccd2ef9,"flixel.input.gamepad.FlxGamepad.anyJustReleased","flixel/input/gamepad/FlxGamepad.hx",433,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_444_anyJustReleasedRaw,"flixel.input.gamepad.FlxGamepad","anyJustReleasedRaw",0x1df8406f,"flixel.input.gamepad.FlxGamepad.anyJustReleasedRaw","flixel/input/gamepad/FlxGamepad.hx",444,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_452_firstPressedID,"flixel.input.gamepad.FlxGamepad","firstPressedID",0xeb182e49,"flixel.input.gamepad.FlxGamepad.firstPressedID","flixel/input/gamepad/FlxGamepad.hx",452,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_465_firstPressedRawID,"flixel.input.gamepad.FlxGamepad","firstPressedRawID",0xee1a19f5,"flixel.input.gamepad.FlxGamepad.firstPressedRawID","flixel/input/gamepad/FlxGamepad.hx",465,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_481_firstJustPressedID,"flixel.input.gamepad.FlxGamepad","firstJustPressedID",0x153c347d,"flixel.input.gamepad.FlxGamepad.firstJustPressedID","flixel/input/gamepad/FlxGamepad.hx",481,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_494_firstJustPressedRawID,"flixel.input.gamepad.FlxGamepad","firstJustPressedRawID",0xcc1cec41,"flixel.input.gamepad.FlxGamepad.firstJustPressedRawID","flixel/input/gamepad/FlxGamepad.hx",494,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_510_firstJustReleasedID,"flixel.input.gamepad.FlxGamepad","firstJustReleasedID",0x71e64c58,"flixel.input.gamepad.FlxGamepad.firstJustReleasedID","flixel/input/gamepad/FlxGamepad.hx",510,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_523_firstJustReleasedRawID,"flixel.input.gamepad.FlxGamepad","firstJustReleasedRawID",0xfa5cef46,"flixel.input.gamepad.FlxGamepad.firstJustReleasedRawID","flixel/input/gamepad/FlxGamepad.hx",523,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_542_getAxis,"flixel.input.gamepad.FlxGamepad","getAxis",0x2a07633b,"flixel.input.gamepad.FlxGamepad.getAxis","flixel/input/gamepad/FlxGamepad.hx",542,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_570_getAxisRaw,"flixel.input.gamepad.FlxGamepad","getAxisRaw",0x2bb6a16d,"flixel.input.gamepad.FlxGamepad.getAxisRaw","flixel/input/gamepad/FlxGamepad.hx",570,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_580_isAxisForAnalogStick,"flixel.input.gamepad.FlxGamepad","isAxisForAnalogStick",0x770b861e,"flixel.input.gamepad.FlxGamepad.isAxisForAnalogStick","flixel/input/gamepad/FlxGamepad.hx",580,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_598_getAnalogStickByAxis,"flixel.input.gamepad.FlxGamepad","getAnalogStickByAxis",0xdbfed05e,"flixel.input.gamepad.FlxGamepad.getAnalogStickByAxis","flixel/input/gamepad/FlxGamepad.hx",598,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_615_getXAxis,"flixel.input.gamepad.FlxGamepad","getXAxis",0xb657655f,"flixel.input.gamepad.FlxGamepad.getXAxis","flixel/input/gamepad/FlxGamepad.hx",615,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_623_getXAxisRaw,"flixel.input.gamepad.FlxGamepad","getXAxisRaw",0x9b9f8dc9,"flixel.input.gamepad.FlxGamepad.getXAxisRaw","flixel/input/gamepad/FlxGamepad.hx",623,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_632_getYAxis,"flixel.input.gamepad.FlxGamepad","getYAxis",0x49bdf9e0,"flixel.input.gamepad.FlxGamepad.getYAxis","flixel/input/gamepad/FlxGamepad.hx",632,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_641_getYAxisRaw,"flixel.input.gamepad.FlxGamepad","getYAxisRaw",0xd4d1ffe8,"flixel.input.gamepad.FlxGamepad.getYAxisRaw","flixel/input/gamepad/FlxGamepad.hx",641,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_652_getAnalogAxes,"flixel.input.gamepad.FlxGamepad","getAnalogAxes",0xfcc3298f,"flixel.input.gamepad.FlxGamepad.getAnalogAxes","flixel/input/gamepad/FlxGamepad.hx",652,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_659_anyButton,"flixel.input.gamepad.FlxGamepad","anyButton",0xd989e1e2,"flixel.input.gamepad.FlxGamepad.anyButton","flixel/input/gamepad/FlxGamepad.hx",659,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_674_anyInput,"flixel.input.gamepad.FlxGamepad","anyInput",0x4fe8921a,"flixel.input.gamepad.FlxGamepad.anyInput","flixel/input/gamepad/FlxGamepad.hx",674,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_704_getAxisValue,"flixel.input.gamepad.FlxGamepad","getAxisValue",0xcd45f636,"flixel.input.gamepad.FlxGamepad.getAxisValue","flixel/input/gamepad/FlxGamepad.hx",704,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_734_getAnalogXAxisValue,"flixel.input.gamepad.FlxGamepad","getAnalogXAxisValue",0xef30b762,"flixel.input.gamepad.FlxGamepad.getAnalogXAxisValue","flixel/input/gamepad/FlxGamepad.hx",734,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_744_getAnalogYAxisValue,"flixel.input.gamepad.FlxGamepad","getAnalogYAxisValue",0xaf7b2f41,"flixel.input.gamepad.FlxGamepad.getAnalogYAxisValue","flixel/input/gamepad/FlxGamepad.hx",744,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_754_getAnalogAxisValueCircular,"flixel.input.gamepad.FlxGamepad","getAnalogAxisValueCircular",0x954ad2e5,"flixel.input.gamepad.FlxGamepad.getAnalogAxisValueCircular","flixel/input/gamepad/FlxGamepad.hx",754,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_772_getAnalogAxisValueIndependent,"flixel.input.gamepad.FlxGamepad","getAnalogAxisValueIndependent",0x41d504b4,"flixel.input.gamepad.FlxGamepad.getAnalogAxisValueIndependent","flixel/input/gamepad/FlxGamepad.hx",772,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_780_handleAxisMove,"flixel.input.gamepad.FlxGamepad","handleAxisMove",0x0dec85b6,"flixel.input.gamepad.FlxGamepad.handleAxisMove","flixel/input/gamepad/FlxGamepad.hx",780,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_799_handleAxisMoveSub,"flixel.input.gamepad.FlxGamepad","handleAxisMoveSub",0xcf80d16a,"flixel.input.gamepad.FlxGamepad.handleAxisMoveSub","flixel/input/gamepad/FlxGamepad.hx",799,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_831_createMappingForModel,"flixel.input.gamepad.FlxGamepad","createMappingForModel",0x1a17db56,"flixel.input.gamepad.FlxGamepad.createMappingForModel","flixel/input/gamepad/FlxGamepad.hx",831,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_851_get_name,"flixel.input.gamepad.FlxGamepad","get_name",0xdbd29e70,"flixel.input.gamepad.FlxGamepad.get_name","flixel/input/gamepad/FlxGamepad.hx",851,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_859_set_model,"flixel.input.gamepad.FlxGamepad","set_model",0xd59c83f0,"flixel.input.gamepad.FlxGamepad.set_model","flixel/input/gamepad/FlxGamepad.hx",859,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_867_set_attachment,"flixel.input.gamepad.FlxGamepad","set_attachment",0xa3a9463c,"flixel.input.gamepad.FlxGamepad.set_attachment","flixel/input/gamepad/FlxGamepad.hx",867,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_875_get_deadZone,"flixel.input.gamepad.FlxGamepad","get_deadZone",0x3fdae195,"flixel.input.gamepad.FlxGamepad.get_deadZone","flixel/input/gamepad/FlxGamepad.hx",875,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_880_set_deadZone,"flixel.input.gamepad.FlxGamepad","set_deadZone",0x54d40509,"flixel.input.gamepad.FlxGamepad.set_deadZone","flixel/input/gamepad/FlxGamepad.hx",880,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_890_getInputLabel,"flixel.input.gamepad.FlxGamepad","getInputLabel",0x585a0ba4,"flixel.input.gamepad.FlxGamepad.getInputLabel","flixel/input/gamepad/FlxGamepad.hx",890,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_900_getMappedInput,"flixel.input.gamepad.FlxGamepad","getMappedInput",0x774d37fd,"flixel.input.gamepad.FlxGamepad.getMappedInput","flixel/input/gamepad/FlxGamepad.hx",900,0xdb78a809)
HX_LOCAL_STACK_FRAME(_hx_pos_0a9014dd1064fc14_905_toString,"flixel.input.gamepad.FlxGamepad","toString",0x4b874148,"flixel.input.gamepad.FlxGamepad.toString","flixel/input/gamepad/FlxGamepad.hx",905,0xdb78a809)
namespace flixel{
namespace input{
namespace gamepad{

void FlxGamepad_obj::__construct(int ID, ::flixel::input::gamepad::FlxGamepadManager Manager, ::flixel::input::gamepad::FlxGamepadModel Model, ::flixel::input::gamepad::FlxGamepadAttachment Attachment){
            	HX_GC_STACKFRAME(&_hx_pos_0a9014dd1064fc14_33_new)
HXLINE( 138)		this->buttons = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 132)		this->_deadZone = ((Float)0.15);
HXLINE( 129)		this->axisActive = false;
HXLINE( 128)		::Array< Float > _g = ::Array_obj< Float >::__new(0);
HXDLIN( 128)		{
HXLINE( 128)			_g->push(0);
HXDLIN( 128)			_g->push(0);
HXDLIN( 128)			_g->push(0);
HXDLIN( 128)			_g->push(0);
HXDLIN( 128)			_g->push(0);
HXDLIN( 128)			_g->push(0);
            		}
HXDLIN( 128)		this->axis = _g;
HXLINE(  85)		this->deadZoneMode = ::flixel::input::gamepad::FlxGamepadDeadZoneMode_obj::INDEPENDENT_AXES_dyn();
HXLINE(  62)		this->connected = true;
HXLINE( 142)		this->id = ID;
HXLINE( 144)		this->manager = Manager;
HXLINE( 146)		this->pressed =  ::flixel::input::gamepad::lists::FlxGamepadButtonList_obj::__alloc( HX_CTX ,1,::hx::ObjectPtr<OBJ_>(this));
HXLINE( 147)		this->released =  ::flixel::input::gamepad::lists::FlxGamepadButtonList_obj::__alloc( HX_CTX ,0,::hx::ObjectPtr<OBJ_>(this));
HXLINE( 148)		this->justPressed =  ::flixel::input::gamepad::lists::FlxGamepadButtonList_obj::__alloc( HX_CTX ,2,::hx::ObjectPtr<OBJ_>(this));
HXLINE( 149)		this->justReleased =  ::flixel::input::gamepad::lists::FlxGamepadButtonList_obj::__alloc( HX_CTX ,-1,::hx::ObjectPtr<OBJ_>(this));
HXLINE( 150)		this->analog =  ::flixel::input::gamepad::lists::FlxGamepadAnalogList_obj::__alloc( HX_CTX ,::hx::ObjectPtr<OBJ_>(this));
HXLINE( 151)		this->motion =  ::flixel::input::gamepad::lists::FlxGamepadMotionValueList_obj::__alloc( HX_CTX ,::hx::ObjectPtr<OBJ_>(this));
HXLINE( 152)		this->pointer =  ::flixel::input::gamepad::lists::FlxGamepadPointerValueList_obj::__alloc( HX_CTX ,::hx::ObjectPtr<OBJ_>(this));
HXLINE( 154)		if (::hx::IsNull( Model )) {
HXLINE( 163)			Model = ::flixel::input::gamepad::FlxGamepadModel_obj::XINPUT_dyn();
            		}
HXLINE( 167)		if (::hx::IsNull( Attachment )) {
HXLINE( 168)			Attachment = ::flixel::input::gamepad::FlxGamepadAttachment_obj::NONE_dyn();
            		}
HXLINE( 170)		this->set_model(Model);
HXLINE( 171)		this->detectedModel = Model;
            	}

Dynamic FlxGamepad_obj::__CreateEmpty() { return new FlxGamepad_obj; }

void *FlxGamepad_obj::_hx_vtable = 0;

Dynamic FlxGamepad_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FlxGamepad_obj > _hx_result = new FlxGamepad_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

bool FlxGamepad_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x38588e22;
}

static ::flixel::util::IFlxDestroyable_obj _hx_flixel_input_gamepad_FlxGamepad__hx_flixel_util_IFlxDestroyable= {
	( void (::hx::Object::*)())&::flixel::input::gamepad::FlxGamepad_obj::destroy,
};

void *FlxGamepad_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0xd4fe2fcd: return &_hx_flixel_input_gamepad_FlxGamepad__hx_flixel_util_IFlxDestroyable;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

 ::flixel::input::gamepad::FlxGamepadButton FlxGamepad_obj::getButton(int RawID){
            	HX_GC_STACKFRAME(&_hx_pos_0a9014dd1064fc14_175_getButton)
HXLINE( 176)		if ((RawID == -1)) {
HXLINE( 177)			return null();
            		}
HXLINE( 178)		 ::flixel::input::gamepad::FlxGamepadButton gamepadButton = this->buttons->__get(RawID).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXLINE( 180)		if (::hx::IsNull( gamepadButton )) {
HXLINE( 182)			gamepadButton =  ::flixel::input::gamepad::FlxGamepadButton_obj::__alloc( HX_CTX ,RawID);
HXLINE( 183)			this->buttons[RawID] = gamepadButton;
            		}
HXLINE( 186)		return gamepadButton;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,getButton,return )

Float FlxGamepad_obj::applyAxisFlip(Float axisValue,int axisID){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_190_applyAxisFlip)
HXLINE( 191)		if (this->mapping->isAxisFlipped(axisID)) {
HXLINE( 192)			axisValue = (axisValue * ( (Float)(-1) ));
            		}
HXLINE( 193)		return axisValue;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxGamepad_obj,applyAxisFlip,return )

void FlxGamepad_obj::update(){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_200_update)
HXLINE( 202)		 ::openfl::ui::GameInputControl control;
HXLINE( 203)		 ::flixel::input::gamepad::FlxGamepadButton button;
HXLINE( 205)		if (::hx::IsNull( this->_device )) {
HXLINE( 206)			return;
            		}
HXLINE( 208)		{
HXLINE( 208)			int _g = 0;
HXDLIN( 208)			int _g1 = this->_device->get_numControls();
HXDLIN( 208)			while((_g < _g1)){
HXLINE( 208)				_g = (_g + 1);
HXDLIN( 208)				int i = (_g - 1);
HXLINE( 210)				control = this->_device->getControlAt(i);
HXLINE( 213)				button = this->getButton(i);
HXLINE( 215)				if (this->isAxisForAnalogStick(i)) {
HXLINE( 217)					this->handleAxisMove(i,control->value,button->value);
            				}
HXLINE( 220)				button->value = control->value;
HXLINE( 222)				Float value = ::Math_obj::abs(control->value);
HXLINE( 224)				if ((value < this->get_deadZone())) {
HXLINE( 226)					button->release();
            				}
            				else {
HXLINE( 228)					if ((value > this->get_deadZone())) {
HXLINE( 230)						button->press();
            					}
            				}
            			}
            		}
HXLINE( 256)		{
HXLINE( 256)			int _g2 = 0;
HXDLIN( 256)			::Array< ::Dynamic> _g3 = this->buttons;
HXDLIN( 256)			while((_g2 < _g3->length)){
HXLINE( 256)				 ::flixel::input::gamepad::FlxGamepadButton button1 = _g3->__get(_g2).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 256)				_g2 = (_g2 + 1);
HXLINE( 258)				if (::hx::IsNotNull( button1 )) {
HXLINE( 260)					button1->update();
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxGamepad_obj,update,(void))

void FlxGamepad_obj::reset(){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_266_reset)
HXLINE( 267)		{
HXLINE( 267)			int _g = 0;
HXDLIN( 267)			::Array< ::Dynamic> _g1 = this->buttons;
HXDLIN( 267)			while((_g < _g1->length)){
HXLINE( 267)				 ::flixel::input::gamepad::FlxGamepadButton button = _g1->__get(_g).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 267)				_g = (_g + 1);
HXLINE( 269)				if (::hx::IsNotNull( button )) {
HXLINE( 271)					button->reset();
            				}
            			}
            		}
HXLINE( 275)		int numAxis = this->axis->length;
HXLINE( 277)		{
HXLINE( 277)			int _g2 = 0;
HXDLIN( 277)			int _g3 = numAxis;
HXDLIN( 277)			while((_g2 < _g3)){
HXLINE( 277)				_g2 = (_g2 + 1);
HXDLIN( 277)				int i = (_g2 - 1);
HXLINE( 279)				this->axis[i] = ( (Float)(0) );
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxGamepad_obj,reset,(void))

void FlxGamepad_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_289_destroy)
HXLINE( 290)		this->connected = false;
HXLINE( 292)		this->buttons = null();
HXLINE( 293)		this->axis = null();
HXLINE( 294)		this->manager = null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxGamepad_obj,destroy,(void))

bool FlxGamepad_obj::checkStatus(int ID,int Status){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_314_checkStatus)
HXDLIN( 314)		switch((int)(ID)){
            			case (int)-2: {
HXLINE( 316)				return this->anyButton(Status);
            			}
            			break;
            			case (int)-1: {
HXLINE( 317)				return !(this->anyButton(Status));
            			}
            			break;
            			default:{
HXLINE( 318)				int RawID = ( (int)(this->mapping->getRawID(ID)) );
HXDLIN( 318)				 ::flixel::input::gamepad::FlxGamepadButton button = this->buttons->__get(RawID).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 318)				if (::hx::IsNotNull( button )) {
HXLINE( 318)					return button->hasState(Status);
            				}
            				else {
HXLINE( 318)					return false;
            				}
            			}
            		}
HXLINE( 314)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxGamepad_obj,checkStatus,return )

bool FlxGamepad_obj::checkStatusRaw(int RawID,int Status){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_330_checkStatusRaw)
HXLINE( 331)		 ::flixel::input::gamepad::FlxGamepadButton button = this->buttons->__get(RawID).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXLINE( 332)		if (::hx::IsNotNull( button )) {
HXLINE( 332)			return button->hasState(Status);
            		}
            		else {
HXLINE( 332)			return false;
            		}
HXDLIN( 332)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxGamepad_obj,checkStatusRaw,return )

bool FlxGamepad_obj::checkButtonArrayState(::Array< int > IDArray,int Status){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_343_checkButtonArrayState)
HXLINE( 344)		if (::hx::IsNull( IDArray )) {
HXLINE( 346)			return false;
            		}
HXLINE( 349)		{
HXLINE( 349)			int _g = 0;
HXDLIN( 349)			while((_g < IDArray->length)){
HXLINE( 349)				int code = IDArray->__get(_g);
HXDLIN( 349)				_g = (_g + 1);
HXLINE( 351)				bool _hx_tmp;
HXDLIN( 351)				switch((int)(code)){
            					case (int)-2: {
HXLINE( 351)						_hx_tmp = this->anyButton(Status);
            					}
            					break;
            					case (int)-1: {
HXLINE( 351)						_hx_tmp = !(this->anyButton(Status));
            					}
            					break;
            					default:{
HXLINE( 351)						int RawID = ( (int)(this->mapping->getRawID(code)) );
HXDLIN( 351)						 ::flixel::input::gamepad::FlxGamepadButton button = this->buttons->__get(RawID).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 351)						if (::hx::IsNotNull( button )) {
HXLINE( 351)							_hx_tmp = button->hasState(Status);
            						}
            						else {
HXLINE( 351)							_hx_tmp = false;
            						}
            					}
            				}
HXDLIN( 351)				if (_hx_tmp) {
HXLINE( 352)					return true;
            				}
            			}
            		}
HXLINE( 355)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxGamepad_obj,checkButtonArrayState,return )

bool FlxGamepad_obj::checkButtonArrayStateRaw(::Array< int > IDArray,int Status){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_366_checkButtonArrayStateRaw)
HXLINE( 367)		if (::hx::IsNull( IDArray )) {
HXLINE( 369)			return false;
            		}
HXLINE( 372)		{
HXLINE( 372)			int _g = 0;
HXDLIN( 372)			while((_g < IDArray->length)){
HXLINE( 372)				int code = IDArray->__get(_g);
HXDLIN( 372)				_g = (_g + 1);
HXLINE( 374)				 ::flixel::input::gamepad::FlxGamepadButton button = this->buttons->__get(code).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 374)				bool _hx_tmp;
HXDLIN( 374)				if (::hx::IsNotNull( button )) {
HXLINE( 374)					_hx_tmp = button->hasState(Status);
            				}
            				else {
HXLINE( 374)					_hx_tmp = false;
            				}
HXDLIN( 374)				if (_hx_tmp) {
HXLINE( 375)					return true;
            				}
            			}
            		}
HXLINE( 378)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxGamepad_obj,checkButtonArrayStateRaw,return )

bool FlxGamepad_obj::anyPressed(::Array< int > IDArray){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_389_anyPressed)
HXDLIN( 389)		return this->checkButtonArrayState(IDArray,1);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,anyPressed,return )

bool FlxGamepad_obj::anyPressedRaw(::Array< int > RawIDArray){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_400_anyPressedRaw)
HXDLIN( 400)		return this->checkButtonArrayStateRaw(RawIDArray,1);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,anyPressedRaw,return )

bool FlxGamepad_obj::anyJustPressed(::Array< int > IDArray){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_411_anyJustPressed)
HXDLIN( 411)		return this->checkButtonArrayState(IDArray,2);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,anyJustPressed,return )

bool FlxGamepad_obj::anyJustPressedRaw(::Array< int > RawIDArray){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_422_anyJustPressedRaw)
HXDLIN( 422)		return this->checkButtonArrayStateRaw(RawIDArray,2);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,anyJustPressedRaw,return )

bool FlxGamepad_obj::anyJustReleased(::Array< int > IDArray){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_433_anyJustReleased)
HXDLIN( 433)		return this->checkButtonArrayState(IDArray,-1);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,anyJustReleased,return )

bool FlxGamepad_obj::anyJustReleasedRaw(::Array< int > RawIDArray){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_444_anyJustReleasedRaw)
HXDLIN( 444)		return this->checkButtonArrayStateRaw(RawIDArray,-1);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,anyJustReleasedRaw,return )

int FlxGamepad_obj::firstPressedID(){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_452_firstPressedID)
HXLINE( 453)		int id = this->firstPressedRawID();
HXLINE( 454)		if ((id < 0)) {
HXLINE( 455)			return id;
            		}
HXLINE( 457)		return this->mapping->getID(id);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxGamepad_obj,firstPressedID,return )

int FlxGamepad_obj::firstPressedRawID(){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_465_firstPressedRawID)
HXLINE( 466)		{
HXLINE( 466)			int _g = 0;
HXDLIN( 466)			::Array< ::Dynamic> _g1 = this->buttons;
HXDLIN( 466)			while((_g < _g1->length)){
HXLINE( 466)				 ::flixel::input::gamepad::FlxGamepadButton button = _g1->__get(_g).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 466)				_g = (_g + 1);
HXLINE( 468)				bool _hx_tmp;
HXDLIN( 468)				if (::hx::IsNotNull( button )) {
HXLINE( 468)					if ((button->current != 1)) {
HXLINE( 468)						_hx_tmp = (button->current == 2);
            					}
            					else {
HXLINE( 468)						_hx_tmp = true;
            					}
            				}
            				else {
HXLINE( 468)					_hx_tmp = false;
            				}
HXDLIN( 468)				if (_hx_tmp) {
HXLINE( 470)					return ( (int)(button->ID) );
            				}
            			}
            		}
HXLINE( 473)		return -1;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxGamepad_obj,firstPressedRawID,return )

int FlxGamepad_obj::firstJustPressedID(){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_481_firstJustPressedID)
HXLINE( 482)		int id = this->firstJustPressedRawID();
HXLINE( 483)		if ((id < 0)) {
HXLINE( 484)			return id;
            		}
HXLINE( 486)		return this->mapping->getID(id);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxGamepad_obj,firstJustPressedID,return )

int FlxGamepad_obj::firstJustPressedRawID(){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_494_firstJustPressedRawID)
HXLINE( 495)		{
HXLINE( 495)			int _g = 0;
HXDLIN( 495)			::Array< ::Dynamic> _g1 = this->buttons;
HXDLIN( 495)			while((_g < _g1->length)){
HXLINE( 495)				 ::flixel::input::gamepad::FlxGamepadButton button = _g1->__get(_g).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 495)				_g = (_g + 1);
HXLINE( 497)				bool _hx_tmp;
HXDLIN( 497)				if (::hx::IsNotNull( button )) {
HXLINE( 497)					_hx_tmp = (button->current == 2);
            				}
            				else {
HXLINE( 497)					_hx_tmp = false;
            				}
HXDLIN( 497)				if (_hx_tmp) {
HXLINE( 499)					return ( (int)(button->ID) );
            				}
            			}
            		}
HXLINE( 502)		return -1;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxGamepad_obj,firstJustPressedRawID,return )

int FlxGamepad_obj::firstJustReleasedID(){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_510_firstJustReleasedID)
HXLINE( 511)		int id = this->firstJustReleasedRawID();
HXLINE( 512)		if ((id < 0)) {
HXLINE( 513)			return id;
            		}
HXLINE( 515)		return this->mapping->getID(id);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxGamepad_obj,firstJustReleasedID,return )

int FlxGamepad_obj::firstJustReleasedRawID(){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_523_firstJustReleasedRawID)
HXLINE( 524)		{
HXLINE( 524)			int _g = 0;
HXDLIN( 524)			::Array< ::Dynamic> _g1 = this->buttons;
HXDLIN( 524)			while((_g < _g1->length)){
HXLINE( 524)				 ::flixel::input::gamepad::FlxGamepadButton button = _g1->__get(_g).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 524)				_g = (_g + 1);
HXLINE( 526)				bool _hx_tmp;
HXDLIN( 526)				if (::hx::IsNotNull( button )) {
HXLINE( 526)					_hx_tmp = (button->current == -1);
            				}
            				else {
HXLINE( 526)					_hx_tmp = false;
            				}
HXDLIN( 526)				if (_hx_tmp) {
HXLINE( 528)					return ( (int)(button->ID) );
            				}
            			}
            		}
HXLINE( 531)		return -1;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxGamepad_obj,firstJustReleasedRawID,return )

Float FlxGamepad_obj::getAxis(int AxisButtonID){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_542_getAxis)
HXDLIN( 542)		Float axisValue = this->getAxisValue(( (int)(this->mapping->getRawID(AxisButtonID)) ));
HXDLIN( 542)		Float _hx_tmp = ::Math_obj::abs(axisValue);
HXDLIN( 542)		if ((_hx_tmp > this->get_deadZone())) {
HXDLIN( 542)			return axisValue;
            		}
            		else {
HXDLIN( 542)			return ( (Float)(0) );
            		}
HXDLIN( 542)		return ((Float)0.);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,getAxis,return )

Float FlxGamepad_obj::getAxisRaw(int RawAxisID){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_570_getAxisRaw)
HXLINE( 571)		Float axisValue = this->getAxisValue(RawAxisID);
HXLINE( 572)		Float _hx_tmp = ::Math_obj::abs(axisValue);
HXDLIN( 572)		if ((_hx_tmp > this->get_deadZone())) {
HXLINE( 574)			return axisValue;
            		}
HXLINE( 576)		return ( (Float)(0) );
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,getAxisRaw,return )

bool FlxGamepad_obj::isAxisForAnalogStick(int AxisIndex){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_580_isAxisForAnalogStick)
HXLINE( 581)		 ::flixel::input::gamepad::FlxTypedGamepadAnalogStick leftStick = this->mapping->leftStick;
HXLINE( 582)		 ::flixel::input::gamepad::FlxTypedGamepadAnalogStick rightStick = this->mapping->rightStick;
HXLINE( 584)		if (::hx::IsNotNull( leftStick )) {
HXLINE( 586)			bool _hx_tmp;
HXDLIN( 586)			if ((AxisIndex != leftStick->x)) {
HXLINE( 586)				_hx_tmp = (AxisIndex == leftStick->y);
            			}
            			else {
HXLINE( 586)				_hx_tmp = true;
            			}
HXDLIN( 586)			if (_hx_tmp) {
HXLINE( 587)				return true;
            			}
            		}
HXLINE( 589)		if (::hx::IsNotNull( rightStick )) {
HXLINE( 591)			bool _hx_tmp1;
HXDLIN( 591)			if ((AxisIndex != rightStick->x)) {
HXLINE( 591)				_hx_tmp1 = (AxisIndex == rightStick->y);
            			}
            			else {
HXLINE( 591)				_hx_tmp1 = true;
            			}
HXDLIN( 591)			if (_hx_tmp1) {
HXLINE( 592)				return true;
            			}
            		}
HXLINE( 594)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,isAxisForAnalogStick,return )

 ::flixel::input::gamepad::FlxTypedGamepadAnalogStick FlxGamepad_obj::getAnalogStickByAxis(int AxisIndex){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_598_getAnalogStickByAxis)
HXLINE( 599)		 ::flixel::input::gamepad::FlxTypedGamepadAnalogStick leftStick = this->mapping->leftStick;
HXLINE( 600)		 ::flixel::input::gamepad::FlxTypedGamepadAnalogStick rightStick = this->mapping->rightStick;
HXLINE( 602)		bool _hx_tmp;
HXDLIN( 602)		bool _hx_tmp1;
HXDLIN( 602)		if (::hx::IsNotNull( leftStick )) {
HXLINE( 602)			_hx_tmp1 = (AxisIndex == leftStick->x);
            		}
            		else {
HXLINE( 602)			_hx_tmp1 = false;
            		}
HXDLIN( 602)		if (!(_hx_tmp1)) {
HXLINE( 602)			_hx_tmp = (AxisIndex == leftStick->y);
            		}
            		else {
HXLINE( 602)			_hx_tmp = true;
            		}
HXDLIN( 602)		if (_hx_tmp) {
HXLINE( 603)			return leftStick;
            		}
HXLINE( 604)		bool _hx_tmp2;
HXDLIN( 604)		bool _hx_tmp3;
HXDLIN( 604)		if (::hx::IsNotNull( rightStick )) {
HXLINE( 604)			_hx_tmp3 = (AxisIndex == rightStick->x);
            		}
            		else {
HXLINE( 604)			_hx_tmp3 = false;
            		}
HXDLIN( 604)		if (!(_hx_tmp3)) {
HXLINE( 604)			_hx_tmp2 = (AxisIndex == rightStick->y);
            		}
            		else {
HXLINE( 604)			_hx_tmp2 = true;
            		}
HXDLIN( 604)		if (_hx_tmp2) {
HXLINE( 605)			return rightStick;
            		}
HXLINE( 606)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,getAnalogStickByAxis,return )

Float FlxGamepad_obj::getXAxis(int AxesButtonID){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_615_getXAxis)
HXDLIN( 615)		return this->getAnalogXAxisValue(this->mapping->getAnalogStick(AxesButtonID));
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,getXAxis,return )

Float FlxGamepad_obj::getXAxisRaw( ::flixel::input::gamepad::FlxTypedGamepadAnalogStick Stick){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_623_getXAxisRaw)
HXDLIN( 623)		return this->getAnalogXAxisValue(Stick);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,getXAxisRaw,return )

Float FlxGamepad_obj::getYAxis(int AxesButtonID){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_632_getYAxis)
HXDLIN( 632)		return this->getYAxisRaw(this->mapping->getAnalogStick(AxesButtonID));
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,getYAxis,return )

Float FlxGamepad_obj::getYAxisRaw( ::flixel::input::gamepad::FlxTypedGamepadAnalogStick Stick){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_641_getYAxisRaw)
HXDLIN( 641)		return this->getAnalogYAxisValue(Stick);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,getYAxisRaw,return )

 ::flixel::math::FlxBasePoint FlxGamepad_obj::getAnalogAxes(int AxesButtonID){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_652_getAnalogAxes)
HXDLIN( 652)		Float x = this->getAnalogXAxisValue(this->mapping->getAnalogStick(AxesButtonID));
HXDLIN( 652)		Float y = this->getYAxisRaw(this->mapping->getAnalogStick(AxesButtonID));
HXDLIN( 652)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(x,y);
HXDLIN( 652)		point->_inPool = false;
HXDLIN( 652)		return point;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,getAnalogAxes,return )

bool FlxGamepad_obj::anyButton(::hx::Null< int >  __o_state){
            		int state = __o_state.Default(1);
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_659_anyButton)
HXLINE( 660)		{
HXLINE( 660)			int _g = 0;
HXDLIN( 660)			::Array< ::Dynamic> _g1 = this->buttons;
HXDLIN( 660)			while((_g < _g1->length)){
HXLINE( 660)				 ::flixel::input::gamepad::FlxGamepadButton button = _g1->__get(_g).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 660)				_g = (_g + 1);
HXLINE( 662)				bool _hx_tmp;
HXDLIN( 662)				if (::hx::IsNotNull( button )) {
HXLINE( 662)					_hx_tmp = button->hasState(state);
            				}
            				else {
HXLINE( 662)					_hx_tmp = false;
            				}
HXDLIN( 662)				if (_hx_tmp) {
HXLINE( 664)					return true;
            				}
            			}
            		}
HXLINE( 667)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,anyButton,return )

bool FlxGamepad_obj::anyInput(){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_674_anyInput)
HXLINE( 675)		if (this->anyButton(null())) {
HXLINE( 676)			return true;
            		}
HXLINE( 678)		int numAxis = this->axis->length;
HXLINE( 680)		{
HXLINE( 680)			int _g = 0;
HXDLIN( 680)			int _g1 = numAxis;
HXDLIN( 680)			while((_g < _g1)){
HXLINE( 680)				_g = (_g + 1);
HXDLIN( 680)				int i = (_g - 1);
HXLINE( 682)				if ((this->axis->__get(0) != 0)) {
HXLINE( 684)					return true;
            				}
            			}
            		}
HXLINE( 700)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxGamepad_obj,anyInput,return )

Float FlxGamepad_obj::getAxisValue(int AxisID){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_704_getAxisValue)
HXLINE( 705)		Float axisValue = ( (Float)(0) );
HXLINE( 708)		if ((AxisID == -1)) {
HXLINE( 710)			return ( (Float)(0) );
            		}
HXLINE( 712)		bool _hx_tmp;
HXDLIN( 712)		bool _hx_tmp1;
HXDLIN( 712)		if (::hx::IsNotNull( this->_device )) {
HXLINE( 712)			_hx_tmp1 = this->_device->enabled;
            		}
            		else {
HXLINE( 712)			_hx_tmp1 = false;
            		}
HXDLIN( 712)		if (_hx_tmp1) {
HXLINE( 712)			 ::Dynamic Max = (this->_device->get_numControls() - 1);
HXDLIN( 712)			if ((AxisID >= 0)) {
HXLINE( 712)				if (::hx::IsNotNull( Max )) {
HXLINE( 712)					_hx_tmp = ::hx::IsLessEq( AxisID,Max );
            				}
            				else {
HXLINE( 712)					_hx_tmp = true;
            				}
            			}
            			else {
HXLINE( 712)				_hx_tmp = false;
            			}
            		}
            		else {
HXLINE( 712)			_hx_tmp = false;
            		}
HXDLIN( 712)		if (_hx_tmp) {
HXLINE( 714)			axisValue = this->_device->getControlAt(AxisID)->value;
            		}
HXLINE( 725)		if (this->isAxisForAnalogStick(AxisID)) {
HXLINE( 727)			Float axisValue1 = axisValue;
HXDLIN( 727)			if (this->mapping->isAxisFlipped(AxisID)) {
HXLINE( 727)				axisValue1 = (axisValue1 * ( (Float)(-1) ));
            			}
HXDLIN( 727)			axisValue = axisValue1;
            		}
HXLINE( 730)		return axisValue;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,getAxisValue,return )

Float FlxGamepad_obj::getAnalogXAxisValue( ::flixel::input::gamepad::FlxTypedGamepadAnalogStick stick){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_734_getAnalogXAxisValue)
HXLINE( 735)		if (::hx::IsNull( stick )) {
HXLINE( 736)			return ( (Float)(0) );
            		}
HXLINE( 737)		if (::hx::IsPointerEq( this->deadZoneMode,::flixel::input::gamepad::FlxGamepadDeadZoneMode_obj::CIRCULAR_dyn() )) {
HXLINE( 738)			return this->getAnalogAxisValueCircular(stick,stick->x);
            		}
            		else {
HXLINE( 740)			return this->getAnalogAxisValueIndependent(stick->x);
            		}
HXLINE( 737)		return ((Float)0.);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,getAnalogXAxisValue,return )

Float FlxGamepad_obj::getAnalogYAxisValue( ::flixel::input::gamepad::FlxTypedGamepadAnalogStick stick){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_744_getAnalogYAxisValue)
HXLINE( 745)		if (::hx::IsNull( stick )) {
HXLINE( 746)			return ( (Float)(0) );
            		}
HXLINE( 747)		if (::hx::IsPointerEq( this->deadZoneMode,::flixel::input::gamepad::FlxGamepadDeadZoneMode_obj::CIRCULAR_dyn() )) {
HXLINE( 748)			return this->getAnalogAxisValueCircular(stick,stick->y);
            		}
            		else {
HXLINE( 750)			return this->getAnalogAxisValueIndependent(stick->y);
            		}
HXLINE( 747)		return ((Float)0.);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,getAnalogYAxisValue,return )

Float FlxGamepad_obj::getAnalogAxisValueCircular( ::flixel::input::gamepad::FlxTypedGamepadAnalogStick stick,int axisID){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_754_getAnalogAxisValueCircular)
HXLINE( 755)		if (::hx::IsNull( stick )) {
HXLINE( 756)			return ( (Float)(0) );
            		}
HXLINE( 757)		Float xAxis = this->getAxisValue(stick->x);
HXLINE( 758)		Float yAxis = this->getAxisValue(stick->y);
HXLINE( 760)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(xAxis,yAxis);
HXDLIN( 760)		point->_inPool = false;
HXDLIN( 760)		 ::flixel::math::FlxBasePoint vector = point;
HXLINE( 761)		Float length = ::Math_obj::sqrt(((vector->x * vector->x) + (vector->y * vector->y)));
HXLINE( 762)		vector->put();
HXLINE( 764)		if ((length > this->get_deadZone())) {
HXLINE( 766)			return this->getAxisValue(axisID);
            		}
HXLINE( 768)		return ( (Float)(0) );
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxGamepad_obj,getAnalogAxisValueCircular,return )

Float FlxGamepad_obj::getAnalogAxisValueIndependent(int axisID){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_772_getAnalogAxisValueIndependent)
HXLINE( 773)		Float axisValue = this->getAxisValue(axisID);
HXLINE( 774)		Float _hx_tmp = ::Math_obj::abs(axisValue);
HXDLIN( 774)		if ((_hx_tmp > this->get_deadZone())) {
HXLINE( 775)			return axisValue;
            		}
HXLINE( 776)		return ( (Float)(0) );
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,getAnalogAxisValueIndependent,return )

void FlxGamepad_obj::handleAxisMove(int axis,Float newValue,Float oldValue){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_780_handleAxisMove)
HXLINE( 781)		Float axisValue = newValue;
HXDLIN( 781)		if (this->mapping->isAxisFlipped(axis)) {
HXLINE( 781)			axisValue = (axisValue * ( (Float)(-1) ));
            		}
HXDLIN( 781)		newValue = axisValue;
HXLINE( 782)		Float axisValue1 = oldValue;
HXDLIN( 782)		if (this->mapping->isAxisFlipped(axis)) {
HXLINE( 782)			axisValue1 = (axisValue1 * ( (Float)(-1) ));
            		}
HXDLIN( 782)		oldValue = axisValue1;
HXLINE( 785)		 ::flixel::input::gamepad::FlxTypedGamepadAnalogStick leftStick = this->mapping->leftStick;
HXDLIN( 785)		 ::flixel::input::gamepad::FlxTypedGamepadAnalogStick rightStick = this->mapping->rightStick;
HXDLIN( 785)		 ::flixel::input::gamepad::FlxTypedGamepadAnalogStick stick;
HXDLIN( 785)		bool stick1;
HXDLIN( 785)		bool stick2;
HXDLIN( 785)		if (::hx::IsNotNull( leftStick )) {
HXLINE( 785)			stick2 = (axis == leftStick->x);
            		}
            		else {
HXLINE( 785)			stick2 = false;
            		}
HXDLIN( 785)		if (!(stick2)) {
HXLINE( 785)			stick1 = (axis == leftStick->y);
            		}
            		else {
HXLINE( 785)			stick1 = true;
            		}
HXDLIN( 785)		if (stick1) {
HXLINE( 785)			stick = leftStick;
            		}
            		else {
HXLINE( 785)			bool stick3;
HXDLIN( 785)			bool stick4;
HXDLIN( 785)			if (::hx::IsNotNull( rightStick )) {
HXLINE( 785)				stick4 = (axis == rightStick->x);
            			}
            			else {
HXLINE( 785)				stick4 = false;
            			}
HXDLIN( 785)			if (!(stick4)) {
HXLINE( 785)				stick3 = (axis == rightStick->y);
            			}
            			else {
HXLINE( 785)				stick3 = true;
            			}
HXDLIN( 785)			if (stick3) {
HXLINE( 785)				stick = rightStick;
            			}
            			else {
HXLINE( 785)				stick = null();
            			}
            		}
HXDLIN( 785)		 ::flixel::input::gamepad::FlxTypedGamepadAnalogStick stick5 = stick;
HXLINE( 786)		bool _hx_tmp;
HXDLIN( 786)		if (::hx::IsPointerNotEq( stick5->mode,::flixel::input::gamepad::FlxAnalogToDigitalMode_obj::ONLY_DIGITAL_dyn() )) {
HXLINE( 786)			_hx_tmp = ::hx::IsPointerEq( stick5->mode,::flixel::input::gamepad::FlxAnalogToDigitalMode_obj::BOTH_dyn() );
            		}
            		else {
HXLINE( 786)			_hx_tmp = true;
            		}
HXDLIN( 786)		if (_hx_tmp) {
HXLINE( 788)			this->handleAxisMoveSub(stick5,axis,newValue,oldValue,((Float)1.0));
HXLINE( 789)			this->handleAxisMoveSub(stick5,axis,newValue,oldValue,((Float)-1.0));
HXLINE( 791)			bool _hx_tmp1 = ::hx::IsPointerEq( stick5->mode,::flixel::input::gamepad::FlxAnalogToDigitalMode_obj::ONLY_DIGITAL_dyn() );
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxGamepad_obj,handleAxisMove,(void))

void FlxGamepad_obj::handleAxisMoveSub( ::flixel::input::gamepad::FlxTypedGamepadAnalogStick stick,int axis,Float value,Float oldValue,::hx::Null< Float >  __o_sign){
            		Float sign = __o_sign.Default(((Float)1.0));
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_799_handleAxisMoveSub)
HXLINE( 800)		int digitalButton = -1;
HXLINE( 802)		if ((axis == stick->x)) {
HXLINE( 804)			if ((sign < 0)) {
HXLINE( 804)				digitalButton = ( (int)(stick->rawLeft) );
            			}
            			else {
HXLINE( 804)				digitalButton = ( (int)(stick->rawRight) );
            			}
            		}
            		else {
HXLINE( 806)			if ((axis == stick->y)) {
HXLINE( 808)				if ((sign < 0)) {
HXLINE( 808)					digitalButton = ( (int)(stick->rawUp) );
            				}
            				else {
HXLINE( 808)					digitalButton = ( (int)(stick->rawDown) );
            				}
            			}
            		}
HXLINE( 811)		Float threshold = stick->digitalThreshold;
HXLINE( 812)		Float valueSign = (value * sign);
HXLINE( 813)		Float oldValueSign = (oldValue * sign);
HXLINE( 815)		bool _hx_tmp;
HXDLIN( 815)		if ((valueSign > threshold)) {
HXLINE( 815)			_hx_tmp = (oldValueSign <= threshold);
            		}
            		else {
HXLINE( 815)			_hx_tmp = false;
            		}
HXDLIN( 815)		if (_hx_tmp) {
HXLINE( 817)			 ::flixel::input::gamepad::FlxGamepadButton btn = this->getButton(digitalButton);
HXLINE( 818)			if (::hx::IsNotNull( btn )) {
HXLINE( 819)				btn->press();
            			}
            		}
            		else {
HXLINE( 821)			bool _hx_tmp1;
HXDLIN( 821)			if ((valueSign <= threshold)) {
HXLINE( 821)				_hx_tmp1 = (oldValueSign > threshold);
            			}
            			else {
HXLINE( 821)				_hx_tmp1 = false;
            			}
HXDLIN( 821)			if (_hx_tmp1) {
HXLINE( 823)				 ::flixel::input::gamepad::FlxGamepadButton btn1 = this->getButton(digitalButton);
HXLINE( 824)				if (::hx::IsNotNull( btn1 )) {
HXLINE( 825)					btn1->release();
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(FlxGamepad_obj,handleAxisMoveSub,(void))

 ::flixel::input::gamepad::mappings::FlxTypedGamepadMapping FlxGamepad_obj::createMappingForModel( ::flixel::input::gamepad::FlxGamepadModel model){
            	HX_GC_STACKFRAME(&_hx_pos_0a9014dd1064fc14_831_createMappingForModel)
HXDLIN( 831)		switch((int)(model->_hx_getIndex())){
            			case (int)0: {
HXLINE( 833)				return  ::flixel::input::gamepad::mappings::LogitechMapping_obj::__alloc( HX_CTX ,this->attachment);
            			}
            			break;
            			case (int)1: {
HXLINE( 834)				return  ::flixel::input::gamepad::mappings::OUYAMapping_obj::__alloc( HX_CTX ,this->attachment);
            			}
            			break;
            			case (int)2: {
HXLINE( 835)				return  ::flixel::input::gamepad::mappings::PS4Mapping_obj::__alloc( HX_CTX ,this->attachment);
            			}
            			break;
            			case (int)3: {
HXLINE( 836)				return  ::flixel::input::gamepad::mappings::PSVitaMapping_obj::__alloc( HX_CTX ,this->attachment);
            			}
            			break;
            			case (int)4: {
HXLINE( 837)				return  ::flixel::input::gamepad::mappings::XInputMapping_obj::__alloc( HX_CTX ,this->attachment);
            			}
            			break;
            			case (int)5: {
HXLINE( 838)				return  ::flixel::input::gamepad::mappings::MayflashWiiRemoteMapping_obj::__alloc( HX_CTX ,this->attachment);
            			}
            			break;
            			case (int)6: {
HXLINE( 839)				return  ::flixel::input::gamepad::mappings::WiiRemoteMapping_obj::__alloc( HX_CTX ,this->attachment);
            			}
            			break;
            			case (int)7: {
HXLINE( 840)				return  ::flixel::input::gamepad::mappings::MFiMapping_obj::__alloc( HX_CTX ,this->attachment);
            			}
            			break;
            			case (int)8: {
HXLINE( 841)				return  ::flixel::input::gamepad::mappings::SwitchProMapping_obj::__alloc( HX_CTX ,this->attachment);
            			}
            			break;
            			case (int)9: {
HXLINE( 842)				return  ::flixel::input::gamepad::mappings::SwitchJoyconLeftMapping_obj::__alloc( HX_CTX ,this->attachment);
            			}
            			break;
            			case (int)10: {
HXLINE( 843)				return  ::flixel::input::gamepad::mappings::SwitchJoyconRightMapping_obj::__alloc( HX_CTX ,this->attachment);
            			}
            			break;
            			default:{
HXLINE( 845)				return  ::flixel::input::gamepad::mappings::XInputMapping_obj::__alloc( HX_CTX ,this->attachment);
            			}
            		}
HXLINE( 831)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,createMappingForModel,return )

::String FlxGamepad_obj::get_name(){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_851_get_name)
HXLINE( 852)		if (::hx::IsNull( this->_device )) {
HXLINE( 853)			return null();
            		}
HXLINE( 854)		return this->_device->name;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxGamepad_obj,get_name,return )

 ::flixel::input::gamepad::FlxGamepadModel FlxGamepad_obj::set_model( ::flixel::input::gamepad::FlxGamepadModel Model){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_859_set_model)
HXLINE( 860)		this->model = Model;
HXLINE( 861)		this->mapping = this->createMappingForModel(this->model);
HXLINE( 863)		return this->model;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,set_model,return )

 ::flixel::input::gamepad::FlxGamepadAttachment FlxGamepad_obj::set_attachment( ::flixel::input::gamepad::FlxGamepadAttachment Attachment){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_867_set_attachment)
HXLINE( 868)		this->attachment = Attachment;
HXLINE( 869)		this->mapping->set_attachment(Attachment);
HXLINE( 870)		return this->attachment;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,set_attachment,return )

Float FlxGamepad_obj::get_deadZone(){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_875_get_deadZone)
HXDLIN( 875)		bool _hx_tmp;
HXDLIN( 875)		if (::hx::IsNotNull( this->manager )) {
HXDLIN( 875)			_hx_tmp = ::hx::IsNull( this->manager->globalDeadZone );
            		}
            		else {
HXDLIN( 875)			_hx_tmp = true;
            		}
HXDLIN( 875)		if (_hx_tmp) {
HXDLIN( 875)			return this->_deadZone;
            		}
            		else {
HXDLIN( 875)			return ( (Float)(this->manager->globalDeadZone) );
            		}
HXDLIN( 875)		return ((Float)0.);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxGamepad_obj,get_deadZone,return )

Float FlxGamepad_obj::set_deadZone(Float deadZone){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_880_set_deadZone)
HXDLIN( 880)		return (this->_deadZone = deadZone);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,set_deadZone,return )

::String FlxGamepad_obj::getInputLabel(int id){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_890_getInputLabel)
HXDLIN( 890)		return this->mapping->getInputLabel(id);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,getInputLabel,return )

 ::flixel::input::gamepad::FlxGamepadMappedInput FlxGamepad_obj::getMappedInput(int id){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_900_getMappedInput)
HXDLIN( 900)		return this->mapping->getMappedInput(id);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxGamepad_obj,getMappedInput,return )

::String FlxGamepad_obj::toString(){
            	HX_STACKFRAME(&_hx_pos_0a9014dd1064fc14_905_toString)
HXLINE( 906)		 ::Dynamic value = this->id;
HXDLIN( 906)		 ::flixel::util::LabelValuePair _this = ::flixel::util::LabelValuePair_obj::_pool->get().StaticCast<  ::flixel::util::LabelValuePair >();
HXDLIN( 906)		_this->label = HX_("id",db,5b,00,00);
HXDLIN( 906)		_this->value = value;
HXLINE( 907)		 ::Dynamic value1 = this->model;
HXDLIN( 907)		 ::flixel::util::LabelValuePair _this1 = ::flixel::util::LabelValuePair_obj::_pool->get().StaticCast<  ::flixel::util::LabelValuePair >();
HXDLIN( 907)		_this1->label = HX_("model",a9,23,58,0c);
HXDLIN( 907)		_this1->value = value1;
HXLINE( 908)		 ::Dynamic value2 = this->get_deadZone();
HXDLIN( 908)		 ::flixel::util::LabelValuePair _this2 = ::flixel::util::LabelValuePair_obj::_pool->get().StaticCast<  ::flixel::util::LabelValuePair >();
HXDLIN( 908)		_this2->label = HX_("deadZone",f0,3e,2e,58);
HXDLIN( 908)		_this2->value = value2;
HXLINE( 905)		return ::flixel::util::FlxStringUtil_obj::getDebugString(::Array_obj< ::Dynamic>::__new(3)->init(0,_this)->init(1,_this1)->init(2,_this2));
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxGamepad_obj,toString,return )


::hx::ObjectPtr< FlxGamepad_obj > FlxGamepad_obj::__new(int ID, ::flixel::input::gamepad::FlxGamepadManager Manager, ::flixel::input::gamepad::FlxGamepadModel Model, ::flixel::input::gamepad::FlxGamepadAttachment Attachment) {
	::hx::ObjectPtr< FlxGamepad_obj > __this = new FlxGamepad_obj();
	__this->__construct(ID,Manager,Model,Attachment);
	return __this;
}

::hx::ObjectPtr< FlxGamepad_obj > FlxGamepad_obj::__alloc(::hx::Ctx *_hx_ctx,int ID, ::flixel::input::gamepad::FlxGamepadManager Manager, ::flixel::input::gamepad::FlxGamepadModel Model, ::flixel::input::gamepad::FlxGamepadAttachment Attachment) {
	FlxGamepad_obj *__this = (FlxGamepad_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FlxGamepad_obj), true, "flixel.input.gamepad.FlxGamepad"));
	*(void **)__this = FlxGamepad_obj::_hx_vtable;
	__this->__construct(ID,Manager,Model,Attachment);
	return __this;
}

FlxGamepad_obj::FlxGamepad_obj()
{
}

void FlxGamepad_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxGamepad);
	HX_MARK_MEMBER_NAME(id,"id");
	HX_MARK_MEMBER_NAME(model,"model");
	HX_MARK_MEMBER_NAME(detectedModel,"detectedModel");
	HX_MARK_MEMBER_NAME(mapping,"mapping");
	HX_MARK_MEMBER_NAME(connected,"connected");
	HX_MARK_MEMBER_NAME(attachment,"attachment");
	HX_MARK_MEMBER_NAME(deadZoneMode,"deadZoneMode");
	HX_MARK_MEMBER_NAME(pressed,"pressed");
	HX_MARK_MEMBER_NAME(released,"released");
	HX_MARK_MEMBER_NAME(justPressed,"justPressed");
	HX_MARK_MEMBER_NAME(justReleased,"justReleased");
	HX_MARK_MEMBER_NAME(analog,"analog");
	HX_MARK_MEMBER_NAME(motion,"motion");
	HX_MARK_MEMBER_NAME(pointer,"pointer");
	HX_MARK_MEMBER_NAME(axis,"axis");
	HX_MARK_MEMBER_NAME(axisActive,"axisActive");
	HX_MARK_MEMBER_NAME(manager,"manager");
	HX_MARK_MEMBER_NAME(_deadZone,"_deadZone");
	HX_MARK_MEMBER_NAME(_device,"_device");
	HX_MARK_MEMBER_NAME(buttons,"buttons");
	HX_MARK_END_CLASS();
}

void FlxGamepad_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(id,"id");
	HX_VISIT_MEMBER_NAME(model,"model");
	HX_VISIT_MEMBER_NAME(detectedModel,"detectedModel");
	HX_VISIT_MEMBER_NAME(mapping,"mapping");
	HX_VISIT_MEMBER_NAME(connected,"connected");
	HX_VISIT_MEMBER_NAME(attachment,"attachment");
	HX_VISIT_MEMBER_NAME(deadZoneMode,"deadZoneMode");
	HX_VISIT_MEMBER_NAME(pressed,"pressed");
	HX_VISIT_MEMBER_NAME(released,"released");
	HX_VISIT_MEMBER_NAME(justPressed,"justPressed");
	HX_VISIT_MEMBER_NAME(justReleased,"justReleased");
	HX_VISIT_MEMBER_NAME(analog,"analog");
	HX_VISIT_MEMBER_NAME(motion,"motion");
	HX_VISIT_MEMBER_NAME(pointer,"pointer");
	HX_VISIT_MEMBER_NAME(axis,"axis");
	HX_VISIT_MEMBER_NAME(axisActive,"axisActive");
	HX_VISIT_MEMBER_NAME(manager,"manager");
	HX_VISIT_MEMBER_NAME(_deadZone,"_deadZone");
	HX_VISIT_MEMBER_NAME(_device,"_device");
	HX_VISIT_MEMBER_NAME(buttons,"buttons");
}

::hx::Val FlxGamepad_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"id") ) { return ::hx::Val( id ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_name() ); }
		if (HX_FIELD_EQ(inName,"axis") ) { return ::hx::Val( axis ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"model") ) { return ::hx::Val( model ); }
		if (HX_FIELD_EQ(inName,"reset") ) { return ::hx::Val( reset_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"analog") ) { return ::hx::Val( analog ); }
		if (HX_FIELD_EQ(inName,"motion") ) { return ::hx::Val( motion ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"mapping") ) { return ::hx::Val( mapping ); }
		if (HX_FIELD_EQ(inName,"pressed") ) { return ::hx::Val( pressed ); }
		if (HX_FIELD_EQ(inName,"pointer") ) { return ::hx::Val( pointer ); }
		if (HX_FIELD_EQ(inName,"manager") ) { return ::hx::Val( manager ); }
		if (HX_FIELD_EQ(inName,"_device") ) { return ::hx::Val( _device ); }
		if (HX_FIELD_EQ(inName,"buttons") ) { return ::hx::Val( buttons ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		if (HX_FIELD_EQ(inName,"getAxis") ) { return ::hx::Val( getAxis_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"deadZone") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_deadZone() ); }
		if (HX_FIELD_EQ(inName,"released") ) { return ::hx::Val( released ); }
		if (HX_FIELD_EQ(inName,"getXAxis") ) { return ::hx::Val( getXAxis_dyn() ); }
		if (HX_FIELD_EQ(inName,"getYAxis") ) { return ::hx::Val( getYAxis_dyn() ); }
		if (HX_FIELD_EQ(inName,"anyInput") ) { return ::hx::Val( anyInput_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_name") ) { return ::hx::Val( get_name_dyn() ); }
		if (HX_FIELD_EQ(inName,"toString") ) { return ::hx::Val( toString_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"connected") ) { return ::hx::Val( connected ); }
		if (HX_FIELD_EQ(inName,"_deadZone") ) { return ::hx::Val( _deadZone ); }
		if (HX_FIELD_EQ(inName,"getButton") ) { return ::hx::Val( getButton_dyn() ); }
		if (HX_FIELD_EQ(inName,"anyButton") ) { return ::hx::Val( anyButton_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_model") ) { return ::hx::Val( set_model_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"attachment") ) { return ::hx::Val( attachment ); }
		if (HX_FIELD_EQ(inName,"axisActive") ) { return ::hx::Val( axisActive ); }
		if (HX_FIELD_EQ(inName,"anyPressed") ) { return ::hx::Val( anyPressed_dyn() ); }
		if (HX_FIELD_EQ(inName,"getAxisRaw") ) { return ::hx::Val( getAxisRaw_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"justPressed") ) { return ::hx::Val( justPressed ); }
		if (HX_FIELD_EQ(inName,"checkStatus") ) { return ::hx::Val( checkStatus_dyn() ); }
		if (HX_FIELD_EQ(inName,"getXAxisRaw") ) { return ::hx::Val( getXAxisRaw_dyn() ); }
		if (HX_FIELD_EQ(inName,"getYAxisRaw") ) { return ::hx::Val( getYAxisRaw_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"deadZoneMode") ) { return ::hx::Val( deadZoneMode ); }
		if (HX_FIELD_EQ(inName,"justReleased") ) { return ::hx::Val( justReleased ); }
		if (HX_FIELD_EQ(inName,"getAxisValue") ) { return ::hx::Val( getAxisValue_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_deadZone") ) { return ::hx::Val( get_deadZone_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_deadZone") ) { return ::hx::Val( set_deadZone_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"detectedModel") ) { return ::hx::Val( detectedModel ); }
		if (HX_FIELD_EQ(inName,"applyAxisFlip") ) { return ::hx::Val( applyAxisFlip_dyn() ); }
		if (HX_FIELD_EQ(inName,"anyPressedRaw") ) { return ::hx::Val( anyPressedRaw_dyn() ); }
		if (HX_FIELD_EQ(inName,"getAnalogAxes") ) { return ::hx::Val( getAnalogAxes_dyn() ); }
		if (HX_FIELD_EQ(inName,"getInputLabel") ) { return ::hx::Val( getInputLabel_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"checkStatusRaw") ) { return ::hx::Val( checkStatusRaw_dyn() ); }
		if (HX_FIELD_EQ(inName,"anyJustPressed") ) { return ::hx::Val( anyJustPressed_dyn() ); }
		if (HX_FIELD_EQ(inName,"firstPressedID") ) { return ::hx::Val( firstPressedID_dyn() ); }
		if (HX_FIELD_EQ(inName,"handleAxisMove") ) { return ::hx::Val( handleAxisMove_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_attachment") ) { return ::hx::Val( set_attachment_dyn() ); }
		if (HX_FIELD_EQ(inName,"getMappedInput") ) { return ::hx::Val( getMappedInput_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"anyJustReleased") ) { return ::hx::Val( anyJustReleased_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"anyJustPressedRaw") ) { return ::hx::Val( anyJustPressedRaw_dyn() ); }
		if (HX_FIELD_EQ(inName,"firstPressedRawID") ) { return ::hx::Val( firstPressedRawID_dyn() ); }
		if (HX_FIELD_EQ(inName,"handleAxisMoveSub") ) { return ::hx::Val( handleAxisMoveSub_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"anyJustReleasedRaw") ) { return ::hx::Val( anyJustReleasedRaw_dyn() ); }
		if (HX_FIELD_EQ(inName,"firstJustPressedID") ) { return ::hx::Val( firstJustPressedID_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"firstJustReleasedID") ) { return ::hx::Val( firstJustReleasedID_dyn() ); }
		if (HX_FIELD_EQ(inName,"getAnalogXAxisValue") ) { return ::hx::Val( getAnalogXAxisValue_dyn() ); }
		if (HX_FIELD_EQ(inName,"getAnalogYAxisValue") ) { return ::hx::Val( getAnalogYAxisValue_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"isAxisForAnalogStick") ) { return ::hx::Val( isAxisForAnalogStick_dyn() ); }
		if (HX_FIELD_EQ(inName,"getAnalogStickByAxis") ) { return ::hx::Val( getAnalogStickByAxis_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"checkButtonArrayState") ) { return ::hx::Val( checkButtonArrayState_dyn() ); }
		if (HX_FIELD_EQ(inName,"firstJustPressedRawID") ) { return ::hx::Val( firstJustPressedRawID_dyn() ); }
		if (HX_FIELD_EQ(inName,"createMappingForModel") ) { return ::hx::Val( createMappingForModel_dyn() ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"firstJustReleasedRawID") ) { return ::hx::Val( firstJustReleasedRawID_dyn() ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"checkButtonArrayStateRaw") ) { return ::hx::Val( checkButtonArrayStateRaw_dyn() ); }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"getAnalogAxisValueCircular") ) { return ::hx::Val( getAnalogAxisValueCircular_dyn() ); }
		break;
	case 29:
		if (HX_FIELD_EQ(inName,"getAnalogAxisValueIndependent") ) { return ::hx::Val( getAnalogAxisValueIndependent_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val FlxGamepad_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"id") ) { id=inValue.Cast< int >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"axis") ) { axis=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"model") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_model(inValue.Cast<  ::flixel::input::gamepad::FlxGamepadModel >()) );model=inValue.Cast<  ::flixel::input::gamepad::FlxGamepadModel >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"analog") ) { analog=inValue.Cast<  ::flixel::input::gamepad::lists::FlxGamepadAnalogList >(); return inValue; }
		if (HX_FIELD_EQ(inName,"motion") ) { motion=inValue.Cast<  ::flixel::input::gamepad::lists::FlxGamepadMotionValueList >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"mapping") ) { mapping=inValue.Cast<  ::flixel::input::gamepad::mappings::FlxTypedGamepadMapping >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pressed") ) { pressed=inValue.Cast<  ::flixel::input::gamepad::lists::FlxGamepadButtonList >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pointer") ) { pointer=inValue.Cast<  ::flixel::input::gamepad::lists::FlxGamepadPointerValueList >(); return inValue; }
		if (HX_FIELD_EQ(inName,"manager") ) { manager=inValue.Cast<  ::flixel::input::gamepad::FlxGamepadManager >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_device") ) { _device=inValue.Cast<  ::openfl::ui::GameInputDevice >(); return inValue; }
		if (HX_FIELD_EQ(inName,"buttons") ) { buttons=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"deadZone") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_deadZone(inValue.Cast< Float >()) ); }
		if (HX_FIELD_EQ(inName,"released") ) { released=inValue.Cast<  ::flixel::input::gamepad::lists::FlxGamepadButtonList >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"connected") ) { connected=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_deadZone") ) { _deadZone=inValue.Cast< Float >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"attachment") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_attachment(inValue.Cast<  ::flixel::input::gamepad::FlxGamepadAttachment >()) );attachment=inValue.Cast<  ::flixel::input::gamepad::FlxGamepadAttachment >(); return inValue; }
		if (HX_FIELD_EQ(inName,"axisActive") ) { axisActive=inValue.Cast< bool >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"justPressed") ) { justPressed=inValue.Cast<  ::flixel::input::gamepad::lists::FlxGamepadButtonList >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"deadZoneMode") ) { deadZoneMode=inValue.Cast<  ::flixel::input::gamepad::FlxGamepadDeadZoneMode >(); return inValue; }
		if (HX_FIELD_EQ(inName,"justReleased") ) { justReleased=inValue.Cast<  ::flixel::input::gamepad::lists::FlxGamepadButtonList >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"detectedModel") ) { detectedModel=inValue.Cast<  ::flixel::input::gamepad::FlxGamepadModel >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void FlxGamepad_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("id",db,5b,00,00));
	outFields->push(HX_("name",4b,72,ff,48));
	outFields->push(HX_("model",a9,23,58,0c));
	outFields->push(HX_("detectedModel",c7,fe,45,f3));
	outFields->push(HX_("mapping",0e,7b,7a,44));
	outFields->push(HX_("connected",c9,e2,f6,a2));
	outFields->push(HX_("attachment",e3,07,73,dd));
	outFields->push(HX_("deadZone",f0,3e,2e,58));
	outFields->push(HX_("deadZoneMode",73,76,8a,42));
	outFields->push(HX_("pressed",a2,d2,e6,39));
	outFields->push(HX_("released",bd,88,e7,76));
	outFields->push(HX_("justPressed",d6,0d,a7,f2));
	outFields->push(HX_("justReleased",09,1b,5b,66));
	outFields->push(HX_("analog",30,d6,21,5f));
	outFields->push(HX_("motion",36,86,5d,cb));
	outFields->push(HX_("pointer",bd,c0,21,51));
	outFields->push(HX_("axis",a1,1c,79,40));
	outFields->push(HX_("axisActive",47,81,10,2c));
	outFields->push(HX_("manager",6d,92,c1,13));
	outFields->push(HX_("_deadZone",4f,36,c4,9f));
	outFields->push(HX_("_device",35,ee,ee,df));
	outFields->push(HX_("buttons",41,52,75,ca));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo FlxGamepad_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(FlxGamepad_obj,id),HX_("id",db,5b,00,00)},
	{::hx::fsObject /*  ::flixel::input::gamepad::FlxGamepadModel */ ,(int)offsetof(FlxGamepad_obj,model),HX_("model",a9,23,58,0c)},
	{::hx::fsObject /*  ::flixel::input::gamepad::FlxGamepadModel */ ,(int)offsetof(FlxGamepad_obj,detectedModel),HX_("detectedModel",c7,fe,45,f3)},
	{::hx::fsObject /*  ::flixel::input::gamepad::mappings::FlxTypedGamepadMapping */ ,(int)offsetof(FlxGamepad_obj,mapping),HX_("mapping",0e,7b,7a,44)},
	{::hx::fsBool,(int)offsetof(FlxGamepad_obj,connected),HX_("connected",c9,e2,f6,a2)},
	{::hx::fsObject /*  ::flixel::input::gamepad::FlxGamepadAttachment */ ,(int)offsetof(FlxGamepad_obj,attachment),HX_("attachment",e3,07,73,dd)},
	{::hx::fsObject /*  ::flixel::input::gamepad::FlxGamepadDeadZoneMode */ ,(int)offsetof(FlxGamepad_obj,deadZoneMode),HX_("deadZoneMode",73,76,8a,42)},
	{::hx::fsObject /*  ::flixel::input::gamepad::lists::FlxGamepadButtonList */ ,(int)offsetof(FlxGamepad_obj,pressed),HX_("pressed",a2,d2,e6,39)},
	{::hx::fsObject /*  ::flixel::input::gamepad::lists::FlxGamepadButtonList */ ,(int)offsetof(FlxGamepad_obj,released),HX_("released",bd,88,e7,76)},
	{::hx::fsObject /*  ::flixel::input::gamepad::lists::FlxGamepadButtonList */ ,(int)offsetof(FlxGamepad_obj,justPressed),HX_("justPressed",d6,0d,a7,f2)},
	{::hx::fsObject /*  ::flixel::input::gamepad::lists::FlxGamepadButtonList */ ,(int)offsetof(FlxGamepad_obj,justReleased),HX_("justReleased",09,1b,5b,66)},
	{::hx::fsObject /*  ::flixel::input::gamepad::lists::FlxGamepadAnalogList */ ,(int)offsetof(FlxGamepad_obj,analog),HX_("analog",30,d6,21,5f)},
	{::hx::fsObject /*  ::flixel::input::gamepad::lists::FlxGamepadMotionValueList */ ,(int)offsetof(FlxGamepad_obj,motion),HX_("motion",36,86,5d,cb)},
	{::hx::fsObject /*  ::flixel::input::gamepad::lists::FlxGamepadPointerValueList */ ,(int)offsetof(FlxGamepad_obj,pointer),HX_("pointer",bd,c0,21,51)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(FlxGamepad_obj,axis),HX_("axis",a1,1c,79,40)},
	{::hx::fsBool,(int)offsetof(FlxGamepad_obj,axisActive),HX_("axisActive",47,81,10,2c)},
	{::hx::fsObject /*  ::flixel::input::gamepad::FlxGamepadManager */ ,(int)offsetof(FlxGamepad_obj,manager),HX_("manager",6d,92,c1,13)},
	{::hx::fsFloat,(int)offsetof(FlxGamepad_obj,_deadZone),HX_("_deadZone",4f,36,c4,9f)},
	{::hx::fsObject /*  ::openfl::ui::GameInputDevice */ ,(int)offsetof(FlxGamepad_obj,_device),HX_("_device",35,ee,ee,df)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(FlxGamepad_obj,buttons),HX_("buttons",41,52,75,ca)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *FlxGamepad_obj_sStaticStorageInfo = 0;
#endif

static ::String FlxGamepad_obj_sMemberFields[] = {
	HX_("id",db,5b,00,00),
	HX_("model",a9,23,58,0c),
	HX_("detectedModel",c7,fe,45,f3),
	HX_("mapping",0e,7b,7a,44),
	HX_("connected",c9,e2,f6,a2),
	HX_("attachment",e3,07,73,dd),
	HX_("deadZoneMode",73,76,8a,42),
	HX_("pressed",a2,d2,e6,39),
	HX_("released",bd,88,e7,76),
	HX_("justPressed",d6,0d,a7,f2),
	HX_("justReleased",09,1b,5b,66),
	HX_("analog",30,d6,21,5f),
	HX_("motion",36,86,5d,cb),
	HX_("pointer",bd,c0,21,51),
	HX_("axis",a1,1c,79,40),
	HX_("axisActive",47,81,10,2c),
	HX_("manager",6d,92,c1,13),
	HX_("_deadZone",4f,36,c4,9f),
	HX_("_device",35,ee,ee,df),
	HX_("buttons",41,52,75,ca),
	HX_("getButton",28,eb,36,56),
	HX_("applyAxisFlip",7c,1f,87,cb),
	HX_("update",09,86,05,87),
	HX_("reset",cf,49,c8,e6),
	HX_("destroy",fa,2c,86,24),
	HX_("checkStatus",1a,ba,0d,e8),
	HX_("checkStatusRaw",ee,9f,30,e1),
	HX_("checkButtonArrayState",32,1b,8c,3e),
	HX_("checkButtonArrayStateRaw",d6,fd,01,5b),
	HX_("anyPressed",16,75,02,90),
	HX_("anyPressedRaw",72,ea,fd,41),
	HX_("anyJustPressed",4a,fa,b6,a6),
	HX_("anyJustPressedRaw",be,9d,89,5f),
	HX_("anyJustReleased",15,14,3a,40),
	HX_("anyJustReleasedRaw",d3,74,6a,66),
	HX_("firstPressedID",ad,60,f7,ba),
	HX_("firstPressedRawID",11,7e,5f,62),
	HX_("firstJustPressedID",e1,68,ae,5d),
	HX_("firstJustPressedRawID",5d,8e,1c,78),
	HX_("firstJustReleasedID",74,ef,61,8d),
	HX_("firstJustReleasedRawID",aa,25,0b,ce),
	HX_("getAxis",57,cc,fb,12),
	HX_("getAxisRaw",d1,d1,2b,cd),
	HX_("isAxisForAnalogStick",82,9b,be,67),
	HX_("getAnalogStickByAxis",c2,e5,b1,cc),
	HX_("getXAxis",c3,f4,3e,a3),
	HX_("getXAxisRaw",e5,b4,b4,40),
	HX_("getYAxis",44,89,a5,36),
	HX_("getYAxisRaw",04,27,e7,79),
	HX_("getAnalogAxes",ab,4f,c5,ee),
	HX_("anyButton",fe,c9,3f,37),
	HX_("anyInput",7e,21,d0,3c),
	HX_("getAxisValue",9a,07,b3,9a),
	HX_("getAnalogXAxisValue",7e,5a,ac,0a),
	HX_("getAnalogYAxisValue",5d,d2,f6,ca),
	HX_("getAnalogAxisValueCircular",49,0b,5e,0f),
	HX_("getAnalogAxisValueIndependent",d0,22,ae,5b),
	HX_("handleAxisMove",1a,b8,cb,dd),
	HX_("handleAxisMoveSub",86,35,c6,43),
	HX_("createMappingForModel",72,7d,17,c6),
	HX_("get_name",d4,2d,ba,c8),
	HX_("set_model",0c,6c,52,33),
	HX_("set_attachment",a0,78,88,73),
	HX_("get_deadZone",f9,f2,47,0d),
	HX_("set_deadZone",6d,16,41,22),
	HX_("getInputLabel",c0,31,5c,4a),
	HX_("getMappedInput",61,6a,2c,47),
	HX_("toString",ac,d0,6e,38),
	::String(null()) };

::hx::Class FlxGamepad_obj::__mClass;

void FlxGamepad_obj::__register()
{
	FlxGamepad_obj _hx_dummy;
	FlxGamepad_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flixel.input.gamepad.FlxGamepad",52,73,7c,f0);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FlxGamepad_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FlxGamepad_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxGamepad_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxGamepad_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flixel
} // end namespace input
} // end namespace gamepad
