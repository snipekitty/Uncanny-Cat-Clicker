// Generated by Haxe 4.3.6
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_path_FlxPathAnchorMode
#include <flixel/path/FlxPathAnchorMode.h>
#endif
#ifndef INCLUDED_flixel_path__FlxPath_AnchorTools
#include <flixel/path/_FlxPath/AnchorTools.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool
#include <flixel/util/FlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_2258d009695b1d8d_46_computeAnchor,"flixel.path._FlxPath.AnchorTools","computeAnchor",0x248e61e5,"flixel.path._FlxPath.AnchorTools.computeAnchor","flixel/path/FlxPath.hx",46,0xbf2b467e)
HX_LOCAL_STACK_FRAME(_hx_pos_2258d009695b1d8d_52_computeAnchorOffset,"flixel.path._FlxPath.AnchorTools","computeAnchorOffset",0x6c946758,"flixel.path._FlxPath.AnchorTools.computeAnchorOffset","flixel/path/FlxPath.hx",52,0xbf2b467e)
namespace flixel{
namespace path{
namespace _FlxPath{

void AnchorTools_obj::__construct() { }

Dynamic AnchorTools_obj::__CreateEmpty() { return new AnchorTools_obj; }

void *AnchorTools_obj::_hx_vtable = 0;

Dynamic AnchorTools_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< AnchorTools_obj > _hx_result = new AnchorTools_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool AnchorTools_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x6b37f4e9;
}

 ::flixel::math::FlxBasePoint AnchorTools_obj::computeAnchor( ::flixel::path::FlxPathAnchorMode mode, ::flixel::FlxObject object, ::flixel::math::FlxBasePoint result){
            	HX_STACKFRAME(&_hx_pos_2258d009695b1d8d_46_computeAnchor)
HXLINE(  47)		result = ::flixel::path::_FlxPath::AnchorTools_obj::computeAnchorOffset(mode,object,result);
HXLINE(  48)		Float y = object->y;
HXDLIN(  48)		result->set_x((result->x + object->x));
HXDLIN(  48)		result->set_y((result->y + y));
HXDLIN(  48)		return result;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(AnchorTools_obj,computeAnchor,return )

 ::flixel::math::FlxBasePoint AnchorTools_obj::computeAnchorOffset( ::flixel::path::FlxPathAnchorMode mode, ::flixel::FlxObject object, ::flixel::math::FlxBasePoint result){
            	HX_STACKFRAME(&_hx_pos_2258d009695b1d8d_52_computeAnchorOffset)
HXLINE(  53)		if (::hx::IsNull( result )) {
HXLINE(  54)			 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN(  54)			point->_inPool = false;
HXDLIN(  54)			result = point;
            		}
            		else {
HXLINE(  56)			result->set_x(( (Float)(0) ));
HXDLIN(  56)			result->set_y(( (Float)(0) ));
            		}
HXLINE(  58)		switch((int)(mode->_hx_getIndex())){
            			case (int)0: {
HXLINE(  72)				return result;
            			}
            			break;
            			case (int)1: {
HXLINE(  70)				Float x = (object->get_width() * ((Float)0.5));
HXDLIN(  70)				Float y = (object->get_height() * ((Float)0.5));
HXDLIN(  70)				result->set_x((result->x + x));
HXDLIN(  70)				result->set_y((result->y + y));
HXDLIN(  70)				return result;
            			}
            			break;
            			case (int)2: {
HXLINE(  61)				if (::Std_obj::isOfType(object,::hx::ClassOf< ::flixel::FlxSprite >())) {
HXLINE(  63)					Float y1 = ::hx::TCast<  ::flixel::FlxSprite >::cast(object)->origin->y;
HXDLIN(  63)					result->set_x((result->x + ::hx::TCast<  ::flixel::FlxSprite >::cast(object)->origin->x));
HXDLIN(  63)					result->set_y((result->y + y1));
HXDLIN(  63)					return result;
            				}
            				else {
HXLINE(  67)					return result;
            				}
            			}
            			break;
            			case (int)3: {
HXLINE(  73)				 ::flixel::math::FlxBasePoint offset = mode->_hx_getObject(0).StaticCast<  ::flixel::math::FlxBasePoint >();
HXLINE(  74)				{
HXLINE(  74)					Float y2 = offset->y;
HXDLIN(  74)					result->set_x((result->x + offset->x));
HXDLIN(  74)					result->set_y((result->y + y2));
            				}
HXDLIN(  74)				{
HXLINE(  74)					 ::flixel::math::FlxBasePoint _this = offset;
HXDLIN(  74)					if (_this->_weak) {
HXLINE(  74)						_this->put();
            					}
            				}
HXDLIN(  74)				return result;
            			}
            			break;
            		}
HXLINE(  58)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(AnchorTools_obj,computeAnchorOffset,return )


AnchorTools_obj::AnchorTools_obj()
{
}

bool AnchorTools_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 13:
		if (HX_FIELD_EQ(inName,"computeAnchor") ) { outValue = computeAnchor_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"computeAnchorOffset") ) { outValue = computeAnchorOffset_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *AnchorTools_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *AnchorTools_obj_sStaticStorageInfo = 0;
#endif

::hx::Class AnchorTools_obj::__mClass;

static ::String AnchorTools_obj_sStaticFields[] = {
	HX_("computeAnchor",4c,69,e7,ca),
	HX_("computeAnchorOffset",ff,75,0f,ad),
	::String(null())
};

void AnchorTools_obj::__register()
{
	AnchorTools_obj _hx_dummy;
	AnchorTools_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flixel.path._FlxPath.AnchorTools",47,6f,74,4f);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &AnchorTools_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(AnchorTools_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< AnchorTools_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = AnchorTools_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = AnchorTools_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flixel
} // end namespace path
} // end namespace _FlxPath
