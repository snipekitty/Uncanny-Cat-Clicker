// Generated by Haxe 4.3.6
#include <hxcpp.h>

#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRandom
#include <flixel/math/FlxRandom.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_path_FlxDiagonalPathfinder
#include <flixel/path/FlxDiagonalPathfinder.h>
#endif
#ifndef INCLUDED_flixel_path_FlxPathSimplifier
#include <flixel/path/FlxPathSimplifier.h>
#endif
#ifndef INCLUDED_flixel_path_FlxTypedPathfinder
#include <flixel/path/FlxTypedPathfinder.h>
#endif
#ifndef INCLUDED_flixel_path_FlxTypedPathfinderData
#include <flixel/path/FlxTypedPathfinderData.h>
#endif
#ifndef INCLUDED_flixel_system_FlxAssets
#include <flixel/system/FlxAssets.h>
#endif
#ifndef INCLUDED_flixel_system_debug_log_LogStyle
#include <flixel/system/debug/log/LogStyle.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_AssetFrontEnd
#include <flixel/system/frontEnds/AssetFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_LogFrontEnd
#include <flixel/system/frontEnds/LogFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxBaseTilemap
#include <flixel/tile/FlxBaseTilemap.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTilemapAutoTiling
#include <flixel/tile/FlxTilemapAutoTiling.h>
#endif
#ifndef INCLUDED_flixel_util_FlxArrayUtil
#include <flixel/util/FlxArrayUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxCollision
#include <flixel/util/FlxCollision.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool
#include <flixel/util/FlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_FlxStringUtil
#include <flixel/util/FlxStringUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_36d94048d9e4941f_19_new,"flixel.tile.FlxBaseTilemap","new",0x601e788b,"flixel.tile.FlxBaseTilemap.new","flixel/tile/FlxBaseTilemap.hx",19,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_115_updateTile,"flixel.tile.FlxBaseTilemap","updateTile",0x4985390c,"flixel.tile.FlxBaseTilemap.updateTile","flixel/tile/FlxBaseTilemap.hx",115,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_120_cacheGraphics,"flixel.tile.FlxBaseTilemap","cacheGraphics",0x589e0d18,"flixel.tile.FlxBaseTilemap.cacheGraphics","flixel/tile/FlxBaseTilemap.hx",120,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_125_initTileObjects,"flixel.tile.FlxBaseTilemap","initTileObjects",0x1ec17ac1,"flixel.tile.FlxBaseTilemap.initTileObjects","flixel/tile/FlxBaseTilemap.hx",125,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_130_updateMap,"flixel.tile.FlxBaseTilemap","updateMap",0xe833827e,"flixel.tile.FlxBaseTilemap.updateMap","flixel/tile/FlxBaseTilemap.hx",130,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_135_computeDimensions,"flixel.tile.FlxBaseTilemap","computeDimensions",0xc850220f,"flixel.tile.FlxBaseTilemap.computeDimensions","flixel/tile/FlxBaseTilemap.hx",135,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_148_getColumnAt,"flixel.tile.FlxBaseTilemap","getColumnAt",0x3650774a,"flixel.tile.FlxBaseTilemap.getColumnAt","flixel/tile/FlxBaseTilemap.hx",148,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_161_getRowAt,"flixel.tile.FlxBaseTilemap","getRowAt",0x972b412c,"flixel.tile.FlxBaseTilemap.getRowAt","flixel/tile/FlxBaseTilemap.hx",161,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_173_getColumnPos,"flixel.tile.FlxBaseTilemap","getColumnPos",0x5023475d,"flixel.tile.FlxBaseTilemap.getColumnPos","flixel/tile/FlxBaseTilemap.hx",173,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_185_getRowPos,"flixel.tile.FlxBaseTilemap","getRowPos",0xaeb9233b,"flixel.tile.FlxBaseTilemap.getRowPos","flixel/tile/FlxBaseTilemap.hx",185,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_197_getTileIndexByCoords,"flixel.tile.FlxBaseTilemap","getTileIndexByCoords",0x5f0cf078,"flixel.tile.FlxBaseTilemap.getTileIndexByCoords","flixel/tile/FlxBaseTilemap.hx",197,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_202_getTileCoordsByIndex,"flixel.tile.FlxBaseTilemap","getTileCoordsByIndex",0x89a6db2e,"flixel.tile.FlxBaseTilemap.getTileCoordsByIndex","flixel/tile/FlxBaseTilemap.hx",202,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_220_ray,"flixel.tile.FlxBaseTilemap","ray",0x60217e15,"flixel.tile.FlxBaseTilemap.ray","flixel/tile/FlxBaseTilemap.hx",220,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_240_rayStep,"flixel.tile.FlxBaseTilemap","rayStep",0x5057c001,"flixel.tile.FlxBaseTilemap.rayStep","flixel/tile/FlxBaseTilemap.hx",240,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_260_calcRayEntry,"flixel.tile.FlxBaseTilemap","calcRayEntry",0xeee3ce52,"flixel.tile.FlxBaseTilemap.calcRayEntry","flixel/tile/FlxBaseTilemap.hx",260,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_286_calcRayExit,"flixel.tile.FlxBaseTilemap","calcRayExit",0xd7c5fd3e,"flixel.tile.FlxBaseTilemap.calcRayExit","flixel/tile/FlxBaseTilemap.hx",286,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_302_isOverlappingTile,"flixel.tile.FlxBaseTilemap","isOverlappingTile",0xa02acde8,"flixel.tile.FlxBaseTilemap.isOverlappingTile","flixel/tile/FlxBaseTilemap.hx",302,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_317_forEachOverlappingTile,"flixel.tile.FlxBaseTilemap","forEachOverlappingTile",0xfe1bf972,"flixel.tile.FlxBaseTilemap.forEachOverlappingTile","flixel/tile/FlxBaseTilemap.hx",317,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_323_overlapsWithCallback,"flixel.tile.FlxBaseTilemap","overlapsWithCallback",0x90f43a8c,"flixel.tile.FlxBaseTilemap.overlapsWithCallback","flixel/tile/FlxBaseTilemap.hx",323,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_347_objectOverlapsTiles,"flixel.tile.FlxBaseTilemap","objectOverlapsTiles",0xb99d42c5,"flixel.tile.FlxBaseTilemap.objectOverlapsTiles","flixel/tile/FlxBaseTilemap.hx",347,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_352_setDirty,"flixel.tile.FlxBaseTilemap","setDirty",0x31f19505,"flixel.tile.FlxBaseTilemap.setDirty","flixel/tile/FlxBaseTilemap.hx",352,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_365_destroy,"flixel.tile.FlxBaseTilemap","destroy",0x44ffc6a5,"flixel.tile.FlxBaseTilemap.destroy","flixel/tile/FlxBaseTilemap.hx",365,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_390_loadMapFromCSV,"flixel.tile.FlxBaseTilemap","loadMapFromCSV",0xbac5ecbb,"flixel.tile.FlxBaseTilemap.loadMapFromCSV","flixel/tile/FlxBaseTilemap.hx",390,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_469_loadMapFromArray,"flixel.tile.FlxBaseTilemap","loadMapFromArray",0x576cd9ce,"flixel.tile.FlxBaseTilemap.loadMapFromArray","flixel/tile/FlxBaseTilemap.hx",469,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_498_loadMapFrom2DArray,"flixel.tile.FlxBaseTilemap","loadMapFrom2DArray",0xb01a13fc,"flixel.tile.FlxBaseTilemap.loadMapFrom2DArray","flixel/tile/FlxBaseTilemap.hx",498,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_532_loadMapFromGraphic,"flixel.tile.FlxBaseTilemap","loadMapFromGraphic",0xe93ffe1d,"flixel.tile.FlxBaseTilemap.loadMapFromGraphic","flixel/tile/FlxBaseTilemap.hx",532,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_540_loadMapHelper,"flixel.tile.FlxBaseTilemap","loadMapHelper",0xc59c560f,"flixel.tile.FlxBaseTilemap.loadMapHelper","flixel/tile/FlxBaseTilemap.hx",540,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_570_postGraphicLoad,"flixel.tile.FlxBaseTilemap","postGraphicLoad",0x0dc00119,"flixel.tile.FlxBaseTilemap.postGraphicLoad","flixel/tile/FlxBaseTilemap.hx",570,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_579_applyAutoTile,"flixel.tile.FlxBaseTilemap","applyAutoTile",0xcc60c5b6,"flixel.tile.FlxBaseTilemap.applyAutoTile","flixel/tile/FlxBaseTilemap.hx",579,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_590_applyCustomRemap,"flixel.tile.FlxBaseTilemap","applyCustomRemap",0x2fd5c57f,"flixel.tile.FlxBaseTilemap.applyCustomRemap","flixel/tile/FlxBaseTilemap.hx",590,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_610_randomizeIndices,"flixel.tile.FlxBaseTilemap","randomizeIndices",0x9015e6eb,"flixel.tile.FlxBaseTilemap.randomizeIndices","flixel/tile/FlxBaseTilemap.hx",610,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_617_randomizeIndices,"flixel.tile.FlxBaseTilemap","randomizeIndices",0x9015e6eb,"flixel.tile.FlxBaseTilemap.randomizeIndices","flixel/tile/FlxBaseTilemap.hx",617,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_646_autoTile,"flixel.tile.FlxBaseTilemap","autoTile",0x7a0f9632,"flixel.tile.FlxBaseTilemap.autoTile","flixel/tile/FlxBaseTilemap.hx",646,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_717_autoTileFull,"flixel.tile.FlxBaseTilemap","autoTileFull",0x4139ace1,"flixel.tile.FlxBaseTilemap.autoTileFull","flixel/tile/FlxBaseTilemap.hx",717,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_764_setCustomTileMappings,"flixel.tile.FlxBaseTilemap","setCustomTileMappings",0x91d80f71,"flixel.tile.FlxBaseTilemap.setCustomTileMappings","flixel/tile/FlxBaseTilemap.hx",764,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_816_getMapIndexAt,"flixel.tile.FlxBaseTilemap","getMapIndexAt",0x39cb2d8a,"flixel.tile.FlxBaseTilemap.getMapIndexAt","flixel/tile/FlxBaseTilemap.hx",816,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_826_getColumn,"flixel.tile.FlxBaseTilemap","getColumn",0xa8357277,"flixel.tile.FlxBaseTilemap.getColumn","flixel/tile/FlxBaseTilemap.hx",826,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_837_getRow,"flixel.tile.FlxBaseTilemap","getRow",0xe5e09fd9,"flixel.tile.FlxBaseTilemap.getRow","flixel/tile/FlxBaseTilemap.hx",837,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_885_tileExistsAt,"flixel.tile.FlxBaseTilemap","tileExistsAt",0xe8fd65b2,"flixel.tile.FlxBaseTilemap.tileExistsAt","flixel/tile/FlxBaseTilemap.hx",885,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_907_columnExistsAt,"flixel.tile.FlxBaseTilemap","columnExistsAt",0x411f189a,"flixel.tile.FlxBaseTilemap.columnExistsAt","flixel/tile/FlxBaseTilemap.hx",907,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_929_rowExistsAt,"flixel.tile.FlxBaseTilemap","rowExistsAt",0x4f071954,"flixel.tile.FlxBaseTilemap.rowExistsAt","flixel/tile/FlxBaseTilemap.hx",929,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1046_getTileIndexAt,"flixel.tile.FlxBaseTilemap","getTileIndexAt",0x334f8fd6,"flixel.tile.FlxBaseTilemap.getTileIndexAt","flixel/tile/FlxBaseTilemap.hx",1046,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1112_getTilePosAt,"flixel.tile.FlxBaseTilemap","getTilePosAt",0xe36b9898,"flixel.tile.FlxBaseTilemap.getTilePosAt","flixel/tile/FlxBaseTilemap.hx",1112,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1124_getAllTilePos,"flixel.tile.FlxBaseTilemap","getAllTilePos",0xc69d0806,"flixel.tile.FlxBaseTilemap.getAllTilePos","flixel/tile/FlxBaseTilemap.hx",1124,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1148_getTile,"flixel.tile.FlxBaseTilemap","getTile",0x3ff9148f,"flixel.tile.FlxBaseTilemap.getTile","flixel/tile/FlxBaseTilemap.hx",1148,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1162_getTileByIndex,"flixel.tile.FlxBaseTilemap","getTileByIndex",0xf0387cec,"flixel.tile.FlxBaseTilemap.getTileByIndex","flixel/tile/FlxBaseTilemap.hx",1162,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1178_getTileCollisions,"flixel.tile.FlxBaseTilemap","getTileCollisions",0x9ca1bd30,"flixel.tile.FlxBaseTilemap.getTileCollisions","flixel/tile/FlxBaseTilemap.hx",1178,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1191_getTileInstances,"flixel.tile.FlxBaseTilemap","getTileInstances",0xa0cac4af,"flixel.tile.FlxBaseTilemap.getTileInstances","flixel/tile/FlxBaseTilemap.hx",1191,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1207_getAllMapIndices,"flixel.tile.FlxBaseTilemap","getAllMapIndices",0xe90742eb,"flixel.tile.FlxBaseTilemap.getAllMapIndices","flixel/tile/FlxBaseTilemap.hx",1207,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1229_forEachMapIndex,"flixel.tile.FlxBaseTilemap","forEachMapIndex",0x7063674b,"flixel.tile.FlxBaseTilemap.forEachMapIndex","flixel/tile/FlxBaseTilemap.hx",1229,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1295_setTileIndexAt,"flixel.tile.FlxBaseTilemap","setTileIndexAt",0x536f784a,"flixel.tile.FlxBaseTilemap.setTileIndexAt","flixel/tile/FlxBaseTilemap.hx",1295,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1310_setTile,"flixel.tile.FlxBaseTilemap","setTile",0x32faa59b,"flixel.tile.FlxBaseTilemap.setTile","flixel/tile/FlxBaseTilemap.hx",1310,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1324_setTileByIndex,"flixel.tile.FlxBaseTilemap","setTileByIndex",0x10586560,"flixel.tile.FlxBaseTilemap.setTileByIndex","flixel/tile/FlxBaseTilemap.hx",1324,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1328_setTileHelper,"flixel.tile.FlxBaseTilemap","setTileHelper",0x66663d69,"flixel.tile.FlxBaseTilemap.setTileHelper","flixel/tile/FlxBaseTilemap.hx",1328,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1353_updateTileWithAutoTile,"flixel.tile.FlxBaseTilemap","updateTileWithAutoTile",0x2eea498f,"flixel.tile.FlxBaseTilemap.updateTileWithAutoTile","flixel/tile/FlxBaseTilemap.hx",1353,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1389_setTileProperties,"flixel.tile.FlxBaseTilemap","setTileProperties",0x2905d56e,"flixel.tile.FlxBaseTilemap.setTileProperties","flixel/tile/FlxBaseTilemap.hx",1389,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1429_getData,"flixel.tile.FlxBaseTilemap","getData",0x355f9f8b,"flixel.tile.FlxBaseTilemap.getData","flixel/tile/FlxBaseTilemap.hx",1429,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1458_findPath,"flixel.tile.FlxBaseTilemap","findPath",0xe6d2ce73,"flixel.tile.FlxBaseTilemap.findPath","flixel/tile/FlxBaseTilemap.hx",1458,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1480_findPathCustom,"flixel.tile.FlxBaseTilemap","findPathCustom",0x382ca284,"flixel.tile.FlxBaseTilemap.findPathCustom","flixel/tile/FlxBaseTilemap.hx",1480,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1494_computePathDistance,"flixel.tile.FlxBaseTilemap","computePathDistance",0x34e53a3c,"flixel.tile.FlxBaseTilemap.computePathDistance","flixel/tile/FlxBaseTilemap.hx",1494,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1516_computePathData,"flixel.tile.FlxBaseTilemap","computePathData",0xbfff2db1,"flixel.tile.FlxBaseTilemap.computePathData","flixel/tile/FlxBaseTilemap.hx",1516,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1520_getDiagonalPathfinder,"flixel.tile.FlxBaseTilemap","getDiagonalPathfinder",0x3b7156c1,"flixel.tile.FlxBaseTilemap.getDiagonalPathfinder","flixel/tile/FlxBaseTilemap.hx",1520,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1537_overlaps,"flixel.tile.FlxBaseTilemap","overlaps",0x8f17af01,"flixel.tile.FlxBaseTilemap.overlaps","flixel/tile/FlxBaseTilemap.hx",1537,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1540_overlaps,"flixel.tile.FlxBaseTilemap","overlaps",0x8f17af01,"flixel.tile.FlxBaseTilemap.overlaps","flixel/tile/FlxBaseTilemap.hx",1540,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1547_tilemapOverlapsCallback,"flixel.tile.FlxBaseTilemap","tilemapOverlapsCallback",0x40d17cea,"flixel.tile.FlxBaseTilemap.tilemapOverlapsCallback","flixel/tile/FlxBaseTilemap.hx",1547,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1571_overlapsAt,"flixel.tile.FlxBaseTilemap","overlapsAt",0x47a26a54,"flixel.tile.FlxBaseTilemap.overlapsAt","flixel/tile/FlxBaseTilemap.hx",1571,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1574_overlapsAt,"flixel.tile.FlxBaseTilemap","overlapsAt",0x47a26a54,"flixel.tile.FlxBaseTilemap.overlapsAt","flixel/tile/FlxBaseTilemap.hx",1574,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1581_tilemapOverlapsAtCallback,"flixel.tile.FlxBaseTilemap","tilemapOverlapsAtCallback",0xbef90c3d,"flixel.tile.FlxBaseTilemap.tilemapOverlapsAtCallback","flixel/tile/FlxBaseTilemap.hx",1581,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1600_overlapsPoint,"flixel.tile.FlxBaseTilemap","overlapsPoint",0x91c6718f,"flixel.tile.FlxBaseTilemap.overlapsPoint","flixel/tile/FlxBaseTilemap.hx",1600,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1614_tileAtPointAllowsCollisions,"flixel.tile.FlxBaseTilemap","tileAtPointAllowsCollisions",0x26e8ec45,"flixel.tile.FlxBaseTilemap.tileAtPointAllowsCollisions","flixel/tile/FlxBaseTilemap.hx",1614,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1626_getBounds,"flixel.tile.FlxBaseTilemap","getBounds",0x47c7aa16,"flixel.tile.FlxBaseTilemap.getBounds","flixel/tile/FlxBaseTilemap.hx",1626,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_26_boot,"flixel.tile.FlxBaseTilemap","boot",0xb2a401a7,"flixel.tile.FlxBaseTilemap.boot","flixel/tile/FlxBaseTilemap.hx",26,0x0139d8e5)
static const int _hx_array_data_6aa6d719_88[] = {
	(int)0,(int)0,(int)0,(int)0,(int)2,(int)2,(int)0,(int)3,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)11,(int)11,(int)0,(int)0,(int)13,(int)13,(int)0,(int)14,(int)0,(int)0,(int)0,(int)0,(int)18,(int)18,(int)0,(int)19,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)51,(int)51,(int)0,(int)0,(int)53,(int)53,(int)0,(int)54,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)62,(int)62,(int)0,(int)0,(int)64,(int)64,(int)0,(int)65,(int)0,(int)0,(int)0,(int)0,(int)69,(int)69,(int)0,(int)70,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)86,(int)86,(int)0,(int)0,(int)88,(int)88,(int)0,(int)89,(int)0,(int)0,(int)0,(int)0,(int)93,(int)93,(int)0,(int)94,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)159,(int)0,(int)0,(int)0,(int)162,(int)0,(int)163,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)172,(int)0,(int)0,(int)0,(int)175,(int)0,(int)176,(int)0,(int)0,(int)0,(int)0,(int)0,(int)181,(int)0,(int)182,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)199,(int)0,(int)0,(int)0,(int)202,(int)0,(int)203,(int)0,(int)0,(int)0,(int)0,(int)0,(int)208,(int)0,(int)209,
};
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_45_boot,"flixel.tile.FlxBaseTilemap","boot",0xb2a401a7,"flixel.tile.FlxBaseTilemap.boot","flixel/tile/FlxBaseTilemap.hx",45,0x0139d8e5)
namespace flixel{
namespace tile{

void FlxBaseTilemap_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_19_new)
HXLINE( 108)		this->_collideIndex = 0;
HXLINE( 107)		this->_drawIndex = 0;
HXLINE( 100)		this->_startingIndex = 0;
HXLINE(  95)		this->_tileObjects = ::cpp::VirtualArray_obj::__new(0);
HXLINE(  51)		this->totalTiles = 0;
HXLINE(  49)		this->heightInTiles = 0;
HXLINE(  47)		this->widthInTiles = 0;
HXLINE(  24)		this->_hx_auto = ::flixel::tile::FlxTilemapAutoTiling_obj::OFF_dyn();
HXLINE( 357)		super::__construct(null(),null(),null(),null());
HXLINE( 359)		this->flixelType = 3;
HXLINE( 360)		this->set_immovable(true);
HXLINE( 361)		this->set_moves(false);
            	}

Dynamic FlxBaseTilemap_obj::__CreateEmpty() { return new FlxBaseTilemap_obj; }

void *FlxBaseTilemap_obj::_hx_vtable = 0;

Dynamic FlxBaseTilemap_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FlxBaseTilemap_obj > _hx_result = new FlxBaseTilemap_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool FlxBaseTilemap_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x7ccf8994) {
		if (inClassId<=(int)0x3d6253b5) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x3d6253b5;
		} else {
			return inClassId==(int)0x7ccf8994;
		}
	} else {
		return inClassId==(int)0x7dab0655;
	}
}

void FlxBaseTilemap_obj::updateTile(int index){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_115_updateTile)
HXDLIN( 115)		HX_STACK_DO_THROW(HX_("updateTile must be implemented",53,76,b0,30));
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,updateTile,(void))

void FlxBaseTilemap_obj::cacheGraphics(int tileWidth,int tileHeight, ::Dynamic tileGraphic){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_120_cacheGraphics)
HXDLIN( 120)		HX_STACK_DO_THROW(HX_("cacheGraphics must be implemented",a9,10,20,38));
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxBaseTilemap_obj,cacheGraphics,(void))

void FlxBaseTilemap_obj::initTileObjects(){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_125_initTileObjects)
HXDLIN( 125)		HX_STACK_DO_THROW(HX_("initTileObjects must be implemented",12,b8,a6,2f));
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxBaseTilemap_obj,initTileObjects,(void))

void FlxBaseTilemap_obj::updateMap(){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_130_updateMap)
HXDLIN( 130)		HX_STACK_DO_THROW(HX_("updateMap must be implemented",8f,ae,0f,b7));
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxBaseTilemap_obj,updateMap,(void))

void FlxBaseTilemap_obj::computeDimensions(){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_135_computeDimensions)
HXDLIN( 135)		HX_STACK_DO_THROW(HX_("computeDimensions must be implemented",a0,79,f6,10));
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxBaseTilemap_obj,computeDimensions,(void))

int FlxBaseTilemap_obj::getColumnAt(Float worldX,::hx::Null< bool >  __o_bind){
            		bool bind = __o_bind.Default(false);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_148_getColumnAt)
HXDLIN( 148)		HX_STACK_DO_THROW(HX_("getColumnAt must be implemented",9b,c0,03,cf));
HXDLIN( 148)		return 0;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxBaseTilemap_obj,getColumnAt,return )

int FlxBaseTilemap_obj::getRowAt(Float worldY,::hx::Null< bool >  __o_bind){
            		bool bind = __o_bind.Default(false);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_161_getRowAt)
HXDLIN( 161)		HX_STACK_DO_THROW(HX_("getRowAt must be implemented",b3,15,95,d1));
HXDLIN( 161)		return 0;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxBaseTilemap_obj,getRowAt,return )

Float FlxBaseTilemap_obj::getColumnPos(Float column,::hx::Null< bool >  __o_midPoint){
            		bool midPoint = __o_midPoint.Default(false);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_173_getColumnPos)
HXDLIN( 173)		HX_STACK_DO_THROW(HX_("getColumnPos must be implemented",e4,db,16,4d));
HXDLIN( 173)		return ((Float)0.);
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxBaseTilemap_obj,getColumnPos,return )

Float FlxBaseTilemap_obj::getRowPos(int row,::hx::Null< bool >  __o_midPoint){
            		bool midPoint = __o_midPoint.Default(false);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_185_getRowPos)
HXDLIN( 185)		HX_STACK_DO_THROW(HX_("getRowPos must be implemented",cc,fb,af,89));
HXDLIN( 185)		return ((Float)0.);
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxBaseTilemap_obj,getRowPos,return )

int FlxBaseTilemap_obj::getTileIndexByCoords( ::flixel::math::FlxBasePoint worldPos){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_197_getTileIndexByCoords)
HXDLIN( 197)		Float worldY = worldPos->y;
HXDLIN( 197)		int column = this->getColumnAt(worldPos->x,null());
HXDLIN( 197)		int row = this->getRowAt(worldY,null());
HXDLIN( 197)		bool _hx_tmp;
HXDLIN( 197)		bool _hx_tmp1;
HXDLIN( 197)		if ((column >= 0)) {
HXDLIN( 197)			_hx_tmp1 = (column < this->widthInTiles);
            		}
            		else {
HXDLIN( 197)			_hx_tmp1 = false;
            		}
HXDLIN( 197)		if (_hx_tmp1) {
HXDLIN( 197)			if ((row >= 0)) {
HXDLIN( 197)				_hx_tmp = (row < this->heightInTiles);
            			}
            			else {
HXDLIN( 197)				_hx_tmp = false;
            			}
            		}
            		else {
HXDLIN( 197)			_hx_tmp = false;
            		}
HXDLIN( 197)		if (_hx_tmp) {
HXDLIN( 197)			return ((row * this->widthInTiles) + column);
            		}
            		else {
HXDLIN( 197)			return -1;
            		}
HXDLIN( 197)		return 0;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,getTileIndexByCoords,return )

 ::flixel::math::FlxBasePoint FlxBaseTilemap_obj::getTileCoordsByIndex(int mapIndex,::hx::Null< bool >  __o_midpoint){
            		bool midpoint = __o_midpoint.Default(true);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_202_getTileCoordsByIndex)
HXDLIN( 202)		bool _hx_tmp;
HXDLIN( 202)		if ((mapIndex >= 0)) {
HXDLIN( 202)			_hx_tmp = (mapIndex < this->_data->length);
            		}
            		else {
HXDLIN( 202)			_hx_tmp = false;
            		}
HXDLIN( 202)		if (_hx_tmp) {
HXDLIN( 202)			int column = ::hx::Mod(mapIndex,this->widthInTiles);
HXDLIN( 202)			int row = ::Std_obj::_hx_int((( (Float)(mapIndex) ) / ( (Float)(this->widthInTiles) )));
HXDLIN( 202)			Float x = this->getColumnPos(( (Float)(column) ),midpoint);
HXDLIN( 202)			Float y = this->getRowPos(row,midpoint);
HXDLIN( 202)			 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(x,y);
HXDLIN( 202)			point->_inPool = false;
HXDLIN( 202)			return point;
            		}
            		else {
HXDLIN( 202)			return null();
            		}
HXDLIN( 202)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxBaseTilemap_obj,getTileCoordsByIndex,return )

bool FlxBaseTilemap_obj::ray( ::flixel::math::FlxBasePoint start, ::flixel::math::FlxBasePoint end, ::flixel::math::FlxBasePoint result){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_220_ray)
HXDLIN( 220)		HX_STACK_DO_THROW(HX_("ray must be implemented",e6,31,5e,58));
HXDLIN( 220)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxBaseTilemap_obj,ray,return )

bool FlxBaseTilemap_obj::rayStep( ::flixel::math::FlxBasePoint start, ::flixel::math::FlxBasePoint end, ::flixel::math::FlxBasePoint result,::hx::Null< Float >  __o_resolution){
            		Float resolution = __o_resolution.Default(1);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_240_rayStep)
HXDLIN( 240)		HX_STACK_DO_THROW(HX_("rayStep must be implemented?",ad,87,6b,eb));
HXDLIN( 240)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxBaseTilemap_obj,rayStep,return )

 ::flixel::math::FlxBasePoint FlxBaseTilemap_obj::calcRayEntry( ::flixel::math::FlxBasePoint start, ::flixel::math::FlxBasePoint end, ::flixel::math::FlxBasePoint result){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_260_calcRayEntry)
HXLINE( 261)		 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN( 261)		_this->x = ( (Float)(0) );
HXDLIN( 261)		_this->y = ( (Float)(0) );
HXDLIN( 261)		_this->width = ( (Float)(0) );
HXDLIN( 261)		_this->height = ( (Float)(0) );
HXDLIN( 261)		 ::flixel::math::FlxRect rect = _this;
HXDLIN( 261)		rect->_inPool = false;
HXDLIN( 261)		 ::flixel::math::FlxRect rect1 = rect;
HXDLIN( 261)		rect1->_weak = true;
HXDLIN( 261)		 ::flixel::math::FlxRect bounds = this->getBounds(rect1);
HXLINE( 263)		bounds->width--;
HXLINE( 264)		bounds->height--;
HXLINE( 266)		return ::flixel::util::FlxCollision_obj::calcRectEntry(bounds,start,end,result);
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxBaseTilemap_obj,calcRayEntry,return )

 ::flixel::math::FlxBasePoint FlxBaseTilemap_obj::calcRayExit( ::flixel::math::FlxBasePoint start, ::flixel::math::FlxBasePoint end, ::flixel::math::FlxBasePoint result){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_286_calcRayExit)
HXDLIN( 286)		return this->calcRayEntry(end,start,result);
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxBaseTilemap_obj,calcRayExit,return )

bool FlxBaseTilemap_obj::isOverlappingTile( ::flixel::FlxObject object, ::Dynamic filter, ::flixel::math::FlxBasePoint position){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_302_isOverlappingTile)
HXDLIN( 302)		HX_STACK_DO_THROW(HX_("overlapsWithCallback must be implemented",93,a3,ff,38));
HXDLIN( 302)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxBaseTilemap_obj,isOverlappingTile,return )

bool FlxBaseTilemap_obj::forEachOverlappingTile( ::flixel::FlxObject object, ::Dynamic func, ::flixel::math::FlxBasePoint position){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_317_forEachOverlappingTile)
HXDLIN( 317)		HX_STACK_DO_THROW(HX_("overlapsWithCallback must be implemented",93,a3,ff,38));
HXDLIN( 317)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxBaseTilemap_obj,forEachOverlappingTile,return )

bool FlxBaseTilemap_obj::overlapsWithCallback( ::flixel::FlxObject object, ::Dynamic callback,::hx::Null< bool >  __o_flipCallbackParams, ::flixel::math::FlxBasePoint position){
            		HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_0,bool,flipCallbackParams, ::Dynamic,callback) HXARGC(2)
            		bool _hx_run( ::Dynamic t, ::flixel::FlxObject o){
            			HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_323_overlapsWithCallback)
HXDLIN( 323)			if (flipCallbackParams) {
HXDLIN( 323)				return ( (bool)(callback(o,t)) );
            			}
            			else {
HXDLIN( 323)				return ( (bool)(callback(t,o)) );
            			}
HXDLIN( 323)			return false;
            		}
            		HX_END_LOCAL_FUNC2(return)

            		bool flipCallbackParams = __o_flipCallbackParams.Default(false);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_323_overlapsWithCallback)
HXDLIN( 323)		return this->objectOverlapsTiles(object, ::Dynamic(new _hx_Closure_0(flipCallbackParams,callback)),position,null());
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxBaseTilemap_obj,overlapsWithCallback,return )

bool FlxBaseTilemap_obj::objectOverlapsTiles( ::Dynamic object, ::Dynamic callback, ::flixel::math::FlxBasePoint position,::hx::Null< bool >  __o_isCollision){
            		bool isCollision = __o_isCollision.Default(true);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_347_objectOverlapsTiles)
HXDLIN( 347)		HX_STACK_DO_THROW(HX_("objectOverlapsTiles must be implemented",96,28,df,c4));
HXDLIN( 347)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxBaseTilemap_obj,objectOverlapsTiles,return )

void FlxBaseTilemap_obj::setDirty(::hx::Null< bool >  __o_dirty){
            		bool dirty = __o_dirty.Default(true);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_352_setDirty)
HXDLIN( 352)		HX_STACK_DO_THROW(HX_("setDirty must be implemented",0c,cc,e0,5f));
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,setDirty,(void))

void FlxBaseTilemap_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_365_destroy)
HXLINE( 366)		this->_data = null();
HXLINE( 367)		this->super::destroy();
            	}


 ::flixel::tile::FlxBaseTilemap FlxBaseTilemap_obj::loadMapFromCSV(::String mapData, ::Dynamic tileGraphic,::hx::Null< int >  __o_tileWidth,::hx::Null< int >  __o_tileHeight, ::flixel::tile::FlxTilemapAutoTiling autoTile,::hx::Null< int >  __o_startingIndex,::hx::Null< int >  __o_drawIndex,::hx::Null< int >  __o_collideIndex){
            		int tileWidth = __o_tileWidth.Default(0);
            		int tileHeight = __o_tileHeight.Default(0);
            		int startingIndex = __o_startingIndex.Default(0);
            		int drawIndex = __o_drawIndex.Default(1);
            		int collideIndex = __o_collideIndex.Default(1);
            	HX_GC_STACKFRAME(&_hx_pos_36d94048d9e4941f_390_loadMapFromCSV)
HXLINE( 392)		if (( (bool)(::flixel::FlxG_obj::assets->exists(mapData,null())) )) {
HXLINE( 394)			mapData = ( (::String)(::flixel::FlxG_obj::assets->getAssetUnsafe(mapData,HX_("text",ad,cc,f9,4c),true)) );
            		}
HXLINE( 398)		this->_data = ::Array_obj< int >::__new();
HXLINE( 399)		::Array< ::String > columns;
HXLINE( 401)		 ::EReg regex =  ::EReg_obj::__alloc( HX_CTX ,HX_("[ \t]*((\r\n)|\r|\n)[ \t]*",22,2c,8d,6d),HX_("g",67,00,00,00));
HXLINE( 402)		::Array< ::String > lines = regex->split(mapData);
HXLINE( 403)		::Array< ::String > _g = ::Array_obj< ::String >::__new(0);
HXDLIN( 403)		{
HXLINE( 403)			int _g1 = 0;
HXDLIN( 403)			::Array< ::String > _g2 = lines;
HXDLIN( 403)			while((_g1 < _g2->length)){
HXLINE( 403)				::String v = _g2->__get(_g1);
HXDLIN( 403)				_g1 = (_g1 + 1);
HXDLIN( 403)				if ((v != HX_("",00,00,00,00))) {
HXLINE( 403)					_g->push(v);
            				}
            			}
            		}
HXDLIN( 403)		::Array< ::String > rows = _g;
HXLINE( 405)		this->heightInTiles = rows->length;
HXLINE( 406)		this->widthInTiles = 0;
HXLINE( 408)		int row = 0;
HXLINE( 409)		while((row < this->heightInTiles)){
HXLINE( 411)			::String rowString = rows->__get(row);
HXLINE( 412)			if (::StringTools_obj::endsWith(rowString,HX_(",",2c,00,00,00))) {
HXLINE( 413)				rowString = rowString.substr(0,(rowString.length - 1));
            			}
HXLINE( 414)			columns = rowString.split(HX_(",",2c,00,00,00));
HXLINE( 416)			if ((columns->length == 0)) {
HXLINE( 418)				this->heightInTiles--;
HXLINE( 419)				continue;
            			}
HXLINE( 421)			if ((this->widthInTiles == 0)) {
HXLINE( 423)				this->widthInTiles = columns->length;
            			}
HXLINE( 426)			int column = 0;
HXLINE( 427)			while((column < this->widthInTiles)){
HXLINE( 430)				::String columnString = columns->__get(column);
HXLINE( 431)				 ::Dynamic curTile = ::Std_obj::parseInt(columnString);
HXLINE( 433)				if (::hx::IsNull( curTile )) {
HXLINE( 434)					HX_STACK_DO_THROW(((((((HX_("String in row ",b2,a4,63,43) + row) + HX_(", column ",96,fc,25,5b)) + column) + HX_(" is not a valid integer: \"",44,67,cc,45)) + columnString) + HX_("\"",22,00,00,00)));
            				}
HXLINE( 436)				this->_data->push(curTile);
HXLINE( 437)				column = (column + 1);
            			}
HXLINE( 440)			row = (row + 1);
            		}
HXLINE( 443)		this->loadMapHelper(tileGraphic,tileWidth,tileHeight,autoTile,startingIndex,drawIndex,collideIndex);
HXLINE( 444)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC8(FlxBaseTilemap_obj,loadMapFromCSV,return )

 ::flixel::tile::FlxBaseTilemap FlxBaseTilemap_obj::loadMapFromArray(::Array< int > mapData,int widthInTiles,int heightInTiles, ::Dynamic tileGraphic,::hx::Null< int >  __o_tileWidth,::hx::Null< int >  __o_tileHeight, ::flixel::tile::FlxTilemapAutoTiling autoTile,::hx::Null< int >  __o_startingIndex,::hx::Null< int >  __o_drawIndex,::hx::Null< int >  __o_collideIndex){
            		int tileWidth = __o_tileWidth.Default(0);
            		int tileHeight = __o_tileHeight.Default(0);
            		int startingIndex = __o_startingIndex.Default(0);
            		int drawIndex = __o_drawIndex.Default(1);
            		int collideIndex = __o_collideIndex.Default(1);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_469_loadMapFromArray)
HXLINE( 470)		this->widthInTiles = widthInTiles;
HXLINE( 471)		this->heightInTiles = heightInTiles;
HXLINE( 472)		this->_data = mapData->copy();
HXLINE( 474)		this->loadMapHelper(tileGraphic,tileWidth,tileHeight,autoTile,startingIndex,drawIndex,collideIndex);
HXLINE( 475)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC10(FlxBaseTilemap_obj,loadMapFromArray,return )

 ::flixel::tile::FlxBaseTilemap FlxBaseTilemap_obj::loadMapFrom2DArray(::Array< ::Dynamic> mapData, ::Dynamic tileGraphic,::hx::Null< int >  __o_tileWidth,::hx::Null< int >  __o_tileHeight, ::flixel::tile::FlxTilemapAutoTiling autoTile,::hx::Null< int >  __o_startingIndex,::hx::Null< int >  __o_drawIndex,::hx::Null< int >  __o_collideIndex){
            		int tileWidth = __o_tileWidth.Default(0);
            		int tileHeight = __o_tileHeight.Default(0);
            		int startingIndex = __o_startingIndex.Default(0);
            		int drawIndex = __o_drawIndex.Default(1);
            		int collideIndex = __o_collideIndex.Default(1);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_498_loadMapFrom2DArray)
HXLINE( 499)		this->widthInTiles = mapData->__get(0).StaticCast< ::Array< int > >()->length;
HXLINE( 500)		this->heightInTiles = mapData->length;
HXLINE( 501)		this->_data = ::flixel::util::FlxArrayUtil_obj::flatten2DArray_Int(mapData);
HXLINE( 503)		this->loadMapHelper(tileGraphic,tileWidth,tileHeight,autoTile,startingIndex,drawIndex,collideIndex);
HXLINE( 504)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC8(FlxBaseTilemap_obj,loadMapFrom2DArray,return )

 ::flixel::tile::FlxBaseTilemap FlxBaseTilemap_obj::loadMapFromGraphic( ::Dynamic mapGraphic,::hx::Null< bool >  __o_invert,::hx::Null< int >  __o_scale,::Array< int > colorMap, ::Dynamic tileGraphic,::hx::Null< int >  __o_tileWidth,::hx::Null< int >  __o_tileHeight, ::flixel::tile::FlxTilemapAutoTiling autoTile,::hx::Null< int >  __o_startingIndex,::hx::Null< int >  __o_drawIndex,::hx::Null< int >  __o_collideIndex){
            		bool invert = __o_invert.Default(false);
            		int scale = __o_scale.Default(1);
            		int tileWidth = __o_tileWidth.Default(0);
            		int tileHeight = __o_tileHeight.Default(0);
            		int startingIndex = __o_startingIndex.Default(0);
            		int drawIndex = __o_drawIndex.Default(1);
            		int collideIndex = __o_collideIndex.Default(1);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_532_loadMapFromGraphic)
HXLINE( 533)		 ::openfl::display::BitmapData mapBitmap = ::flixel::_hx_system::FlxAssets_obj::resolveBitmapData(mapGraphic);
HXLINE( 534)		::String mapData = ::flixel::util::FlxStringUtil_obj::bitmapToCSV(mapBitmap,invert,scale,colorMap);
HXLINE( 535)		return this->loadMapFromCSV(mapData,tileGraphic,tileWidth,tileHeight,autoTile,startingIndex,drawIndex,collideIndex);
            	}


HX_DEFINE_DYNAMIC_FUNC11(FlxBaseTilemap_obj,loadMapFromGraphic,return )

void FlxBaseTilemap_obj::loadMapHelper( ::Dynamic tileGraphic,::hx::Null< int >  __o_tileWidth,::hx::Null< int >  __o_tileHeight, ::flixel::tile::FlxTilemapAutoTiling autoTile,::hx::Null< int >  __o_startingIndex,::hx::Null< int >  __o_drawIndex,::hx::Null< int >  __o_collideIndex){
            		int tileWidth = __o_tileWidth.Default(0);
            		int tileHeight = __o_tileHeight.Default(0);
            		int startingIndex = __o_startingIndex.Default(0);
            		int drawIndex = __o_drawIndex.Default(1);
            		int collideIndex = __o_collideIndex.Default(1);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_540_loadMapHelper)
HXLINE( 542)		{
HXLINE( 542)			int _g = 0;
HXDLIN( 542)			int _g1 = this->_data->length;
HXDLIN( 542)			while((_g < _g1)){
HXLINE( 542)				_g = (_g + 1);
HXDLIN( 542)				int i = (_g - 1);
HXLINE( 544)				if ((this->_data->__get(i) < 0)) {
HXLINE( 545)					this->_data[i] = 0;
            				}
            			}
            		}
HXLINE( 548)		this->totalTiles = this->_data->length;
HXLINE( 549)		 ::flixel::tile::FlxTilemapAutoTiling _hx_tmp;
HXDLIN( 549)		if (::hx::IsNull( autoTile )) {
HXLINE( 549)			_hx_tmp = ::flixel::tile::FlxTilemapAutoTiling_obj::OFF_dyn();
            		}
            		else {
HXLINE( 549)			_hx_tmp = autoTile;
            		}
HXDLIN( 549)		this->_hx_auto = _hx_tmp;
HXLINE( 550)		int _hx_tmp1;
HXDLIN( 550)		if ((startingIndex <= 0)) {
HXLINE( 550)			_hx_tmp1 = 0;
            		}
            		else {
HXLINE( 550)			_hx_tmp1 = startingIndex;
            		}
HXDLIN( 550)		this->_startingIndex = _hx_tmp1;
HXLINE( 552)		if (::hx::IsPointerNotEq( this->_hx_auto,::flixel::tile::FlxTilemapAutoTiling_obj::OFF_dyn() )) {
HXLINE( 554)			this->_startingIndex = 1;
HXLINE( 555)			drawIndex = 1;
HXLINE( 556)			collideIndex = 1;
            		}
HXLINE( 559)		this->_drawIndex = drawIndex;
HXLINE( 560)		this->_collideIndex = collideIndex;
HXLINE( 562)		this->applyAutoTile();
HXLINE( 563)		this->applyCustomRemap();
HXLINE( 564)		this->randomizeIndices();
HXLINE( 565)		this->cacheGraphics(tileWidth,tileHeight,tileGraphic);
HXLINE( 566)		this->postGraphicLoad();
            	}


HX_DEFINE_DYNAMIC_FUNC7(FlxBaseTilemap_obj,loadMapHelper,(void))

void FlxBaseTilemap_obj::postGraphicLoad(){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_570_postGraphicLoad)
HXLINE( 571)		this->initTileObjects();
HXLINE( 572)		this->computeDimensions();
HXLINE( 573)		this->updateMap();
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxBaseTilemap_obj,postGraphicLoad,(void))

void FlxBaseTilemap_obj::applyAutoTile(){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_579_applyAutoTile)
HXDLIN( 579)		if (::hx::IsPointerNotEq( this->_hx_auto,::flixel::tile::FlxTilemapAutoTiling_obj::OFF_dyn() )) {
HXLINE( 581)			int i = 0;
HXLINE( 582)			while((i < this->totalTiles)){
HXLINE( 584)				i = (i + 1);
HXDLIN( 584)				this->autoTile((i - 1));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxBaseTilemap_obj,applyAutoTile,(void))

void FlxBaseTilemap_obj::applyCustomRemap(){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_590_applyCustomRemap)
HXLINE( 591)		int i = 0;
HXLINE( 593)		if (::hx::IsNotNull( this->customTileRemap )) {
HXLINE( 595)			while((i < this->totalTiles)){
HXLINE( 597)				int oldIndex = this->_data->__get(i);
HXLINE( 598)				int newIndex = oldIndex;
HXLINE( 599)				if ((oldIndex < this->customTileRemap->length)) {
HXLINE( 601)					newIndex = this->customTileRemap->__get(oldIndex);
            				}
HXLINE( 603)				this->_data[i] = newIndex;
HXLINE( 604)				i = (i + 1);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxBaseTilemap_obj,applyCustomRemap,(void))

void FlxBaseTilemap_obj::randomizeIndices(){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_610_randomizeIndices)
HXLINE( 611)		int i = 0;
HXLINE( 613)		if (::hx::IsNotNull( this->_randomIndices )) {
HXLINE( 615)			 ::Dynamic randLambda;
HXDLIN( 615)			if (::hx::IsNotNull( this->_randomLambda )) {
HXLINE( 615)				randLambda = this->_randomLambda;
            			}
            			else {
            				HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            				Float _hx_run(){
            					HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_617_randomizeIndices)
HXLINE( 617)					return ::flixel::FlxG_obj::random->_hx_float(null(),null(),null());
            				}
            				HX_END_LOCAL_FUNC0(return)

HXLINE( 615)				randLambda =  ::Dynamic(new _hx_Closure_0());
            			}
HXLINE( 620)			while((i < this->totalTiles)){
HXLINE( 622)				int oldIndex = this->_data->__get(i);
HXLINE( 623)				int j = 0;
HXLINE( 624)				int newIndex = oldIndex;
HXLINE( 625)				{
HXLINE( 625)					int _g = 0;
HXDLIN( 625)					::Array< int > _g1 = this->_randomIndices;
HXDLIN( 625)					while((_g < _g1->length)){
HXLINE( 625)						int rand = _g1->__get(_g);
HXDLIN( 625)						_g = (_g + 1);
HXLINE( 627)						if ((oldIndex == rand)) {
HXLINE( 629)							Float k = ( (Float)(randLambda()) );
HXDLIN( 629)							int k1 = ::Std_obj::_hx_int((k * ( (Float)(this->_randomChoices->__get(j).StaticCast< ::Array< int > >()->length) )));
HXLINE( 630)							newIndex = this->_randomChoices->__get(j).StaticCast< ::Array< int > >()->__get(k1);
            						}
HXLINE( 632)						j = (j + 1);
            					}
            				}
HXLINE( 634)				this->_data[i] = newIndex;
HXLINE( 635)				i = (i + 1);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxBaseTilemap_obj,randomizeIndices,(void))

void FlxBaseTilemap_obj::autoTile(int index){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_646_autoTile)
HXLINE( 647)		if ((this->_data->__get(index) == 0)) {
HXLINE( 649)			return;
            		}
HXLINE( 652)		if (::hx::IsPointerEq( this->_hx_auto,::flixel::tile::FlxTilemapAutoTiling_obj::FULL_dyn() )) {
HXLINE( 654)			this->autoTileFull(index);
HXLINE( 655)			return;
            		}
HXLINE( 658)		this->_data[index] = 0;
HXLINE( 661)		bool _hx_tmp;
HXDLIN( 661)		if (((index - this->widthInTiles) >= 0)) {
HXLINE( 661)			_hx_tmp = (this->_data->__get((index - this->widthInTiles)) > 0);
            		}
            		else {
HXLINE( 661)			_hx_tmp = true;
            		}
HXDLIN( 661)		if (_hx_tmp) {
HXLINE( 663)			::Array< int > base = this->_data;
HXDLIN( 663)			int index1 = index;
HXDLIN( 663)			base[index1] = (base->__get(index1) + 1);
            		}
HXLINE( 666)		bool _hx_tmp1;
HXDLIN( 666)		if ((::hx::Mod(index,this->widthInTiles) < (this->widthInTiles - 1))) {
HXLINE( 666)			_hx_tmp1 = (this->_data->__get((index + 1)) > 0);
            		}
            		else {
HXLINE( 666)			_hx_tmp1 = true;
            		}
HXDLIN( 666)		if (_hx_tmp1) {
HXLINE( 668)			::Array< int > base1 = this->_data;
HXDLIN( 668)			int index2 = index;
HXDLIN( 668)			base1[index2] = (base1->__get(index2) + 2);
            		}
HXLINE( 671)		bool _hx_tmp2;
HXDLIN( 671)		int _hx_tmp3 = ::Std_obj::_hx_int(( (Float)((index + this->widthInTiles)) ));
HXDLIN( 671)		if ((_hx_tmp3 < this->totalTiles)) {
HXLINE( 671)			_hx_tmp2 = (this->_data->__get((index + this->widthInTiles)) > 0);
            		}
            		else {
HXLINE( 671)			_hx_tmp2 = true;
            		}
HXDLIN( 671)		if (_hx_tmp2) {
HXLINE( 673)			::Array< int > base2 = this->_data;
HXDLIN( 673)			int index3 = index;
HXDLIN( 673)			base2[index3] = (base2->__get(index3) + 4);
            		}
HXLINE( 676)		bool _hx_tmp4;
HXDLIN( 676)		if ((::hx::Mod(index,this->widthInTiles) > 0)) {
HXLINE( 676)			_hx_tmp4 = (this->_data->__get((index - 1)) > 0);
            		}
            		else {
HXLINE( 676)			_hx_tmp4 = true;
            		}
HXDLIN( 676)		if (_hx_tmp4) {
HXLINE( 678)			::Array< int > base3 = this->_data;
HXDLIN( 678)			int index4 = index;
HXDLIN( 678)			base3[index4] = (base3->__get(index4) + 8);
            		}
HXLINE( 682)		bool _hx_tmp5;
HXDLIN( 682)		if (::hx::IsPointerEq( this->_hx_auto,::flixel::tile::FlxTilemapAutoTiling_obj::ALT_dyn() )) {
HXLINE( 682)			_hx_tmp5 = (this->_data->__get(index) == 15);
            		}
            		else {
HXLINE( 682)			_hx_tmp5 = false;
            		}
HXDLIN( 682)		if (_hx_tmp5) {
HXLINE( 685)			bool _hx_tmp6;
HXDLIN( 685)			bool _hx_tmp7;
HXDLIN( 685)			if ((::hx::Mod(index,this->widthInTiles) > 0)) {
HXLINE( 685)				int _hx_tmp8 = ::Std_obj::_hx_int(( (Float)((index + this->widthInTiles)) ));
HXDLIN( 685)				_hx_tmp7 = (_hx_tmp8 < this->totalTiles);
            			}
            			else {
HXLINE( 685)				_hx_tmp7 = false;
            			}
HXDLIN( 685)			if (_hx_tmp7) {
HXLINE( 685)				_hx_tmp6 = (this->_data->__get(((index + this->widthInTiles) - 1)) <= 0);
            			}
            			else {
HXLINE( 685)				_hx_tmp6 = false;
            			}
HXDLIN( 685)			if (_hx_tmp6) {
HXLINE( 687)				this->_data[index] = 1;
            			}
HXLINE( 690)			bool _hx_tmp9;
HXDLIN( 690)			bool _hx_tmp10;
HXDLIN( 690)			if ((::hx::Mod(index,this->widthInTiles) > 0)) {
HXLINE( 690)				_hx_tmp10 = ((index - this->widthInTiles) >= 0);
            			}
            			else {
HXLINE( 690)				_hx_tmp10 = false;
            			}
HXDLIN( 690)			if (_hx_tmp10) {
HXLINE( 690)				_hx_tmp9 = (this->_data->__get(((index - this->widthInTiles) - 1)) <= 0);
            			}
            			else {
HXLINE( 690)				_hx_tmp9 = false;
            			}
HXDLIN( 690)			if (_hx_tmp9) {
HXLINE( 692)				this->_data[index] = 2;
            			}
HXLINE( 695)			bool _hx_tmp11;
HXDLIN( 695)			bool _hx_tmp12;
HXDLIN( 695)			if ((::hx::Mod(index,this->widthInTiles) < (this->widthInTiles - 1))) {
HXLINE( 695)				_hx_tmp12 = ((index - this->widthInTiles) >= 0);
            			}
            			else {
HXLINE( 695)				_hx_tmp12 = false;
            			}
HXDLIN( 695)			if (_hx_tmp12) {
HXLINE( 695)				_hx_tmp11 = (this->_data->__get(((index - this->widthInTiles) + 1)) <= 0);
            			}
            			else {
HXLINE( 695)				_hx_tmp11 = false;
            			}
HXDLIN( 695)			if (_hx_tmp11) {
HXLINE( 697)				this->_data[index] = 4;
            			}
HXLINE( 700)			bool _hx_tmp13;
HXDLIN( 700)			bool _hx_tmp14;
HXDLIN( 700)			if ((::hx::Mod(index,this->widthInTiles) < (this->widthInTiles - 1))) {
HXLINE( 701)				int _hx_tmp15 = ::Std_obj::_hx_int(( (Float)((index + this->widthInTiles)) ));
HXLINE( 700)				_hx_tmp14 = (_hx_tmp15 < this->totalTiles);
            			}
            			else {
HXLINE( 700)				_hx_tmp14 = false;
            			}
HXDLIN( 700)			if (_hx_tmp14) {
HXLINE( 700)				_hx_tmp13 = (this->_data->__get(((index + this->widthInTiles) + 1)) <= 0);
            			}
            			else {
HXLINE( 700)				_hx_tmp13 = false;
            			}
HXDLIN( 700)			if (_hx_tmp13) {
HXLINE( 704)				this->_data[index] = 8;
            			}
            		}
HXLINE( 708)		::Array< int > base4 = this->_data;
HXDLIN( 708)		int index5 = index;
HXDLIN( 708)		base4[index5] = (base4->__get(index5) + 1);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,autoTile,(void))

void FlxBaseTilemap_obj::autoTileFull(int index){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_717_autoTileFull)
HXLINE( 718)		this->_data[index] = 0;
HXLINE( 720)		bool wallUp = ((index - this->widthInTiles) < 0);
HXLINE( 721)		bool wallRight = (::hx::Mod(index,this->widthInTiles) >= (this->widthInTiles - 1));
HXLINE( 722)		int wallDown = ::Std_obj::_hx_int(( (Float)((index + this->widthInTiles)) ));
HXDLIN( 722)		bool wallDown1 = (wallDown >= this->totalTiles);
HXLINE( 723)		bool wallLeft = (::hx::Mod(index,this->widthInTiles) <= 0);
HXLINE( 725)		bool up;
HXDLIN( 725)		if (!(wallUp)) {
HXLINE( 725)			up = (this->_data->__get((index - this->widthInTiles)) > 0);
            		}
            		else {
HXLINE( 725)			up = true;
            		}
HXLINE( 726)		bool upRight;
HXDLIN( 726)		bool upRight1;
HXDLIN( 726)		if (!(wallUp)) {
HXLINE( 726)			upRight1 = wallRight;
            		}
            		else {
HXLINE( 726)			upRight1 = true;
            		}
HXDLIN( 726)		if (!(upRight1)) {
HXLINE( 726)			upRight = (this->_data->__get(((index - this->widthInTiles) + 1)) > 0);
            		}
            		else {
HXLINE( 726)			upRight = true;
            		}
HXLINE( 727)		bool right;
HXDLIN( 727)		if (!(wallRight)) {
HXLINE( 727)			right = (this->_data->__get((index + 1)) > 0);
            		}
            		else {
HXLINE( 727)			right = true;
            		}
HXLINE( 728)		bool rightDown;
HXDLIN( 728)		bool rightDown1;
HXDLIN( 728)		if (!(wallRight)) {
HXLINE( 728)			rightDown1 = wallDown1;
            		}
            		else {
HXLINE( 728)			rightDown1 = true;
            		}
HXDLIN( 728)		if (!(rightDown1)) {
HXLINE( 728)			rightDown = (this->_data->__get(((index + this->widthInTiles) + 1)) > 0);
            		}
            		else {
HXLINE( 728)			rightDown = true;
            		}
HXLINE( 729)		bool down;
HXDLIN( 729)		if (!(wallDown1)) {
HXLINE( 729)			down = (this->_data->__get((index + this->widthInTiles)) > 0);
            		}
            		else {
HXLINE( 729)			down = true;
            		}
HXLINE( 730)		bool downLeft;
HXDLIN( 730)		bool downLeft1;
HXDLIN( 730)		if (!(wallDown1)) {
HXLINE( 730)			downLeft1 = wallLeft;
            		}
            		else {
HXLINE( 730)			downLeft1 = true;
            		}
HXDLIN( 730)		if (!(downLeft1)) {
HXLINE( 730)			downLeft = (this->_data->__get(((index + this->widthInTiles) - 1)) > 0);
            		}
            		else {
HXLINE( 730)			downLeft = true;
            		}
HXLINE( 731)		bool left;
HXDLIN( 731)		if (!(wallLeft)) {
HXLINE( 731)			left = (this->_data->__get((index - 1)) > 0);
            		}
            		else {
HXLINE( 731)			left = true;
            		}
HXLINE( 732)		bool leftUp;
HXDLIN( 732)		bool leftUp1;
HXDLIN( 732)		if (!(wallLeft)) {
HXLINE( 732)			leftUp1 = wallUp;
            		}
            		else {
HXLINE( 732)			leftUp1 = true;
            		}
HXDLIN( 732)		if (!(leftUp1)) {
HXLINE( 732)			leftUp = (this->_data->__get(((index - this->widthInTiles) - 1)) > 0);
            		}
            		else {
HXLINE( 732)			leftUp = true;
            		}
HXLINE( 734)		if (up) {
HXLINE( 735)			::Array< int > base = this->_data;
HXDLIN( 735)			int index1 = index;
HXDLIN( 735)			base[index1] = (base->__get(index1) + 1);
            		}
HXLINE( 736)		bool _hx_tmp;
HXDLIN( 736)		bool _hx_tmp1;
HXDLIN( 736)		if (upRight) {
HXLINE( 736)			_hx_tmp1 = up;
            		}
            		else {
HXLINE( 736)			_hx_tmp1 = false;
            		}
HXDLIN( 736)		if (_hx_tmp1) {
HXLINE( 736)			_hx_tmp = right;
            		}
            		else {
HXLINE( 736)			_hx_tmp = false;
            		}
HXDLIN( 736)		if (_hx_tmp) {
HXLINE( 737)			::Array< int > base1 = this->_data;
HXDLIN( 737)			int index2 = index;
HXDLIN( 737)			base1[index2] = (base1->__get(index2) + 2);
            		}
HXLINE( 738)		if (right) {
HXLINE( 739)			::Array< int > base2 = this->_data;
HXDLIN( 739)			int index3 = index;
HXDLIN( 739)			base2[index3] = (base2->__get(index3) + 4);
            		}
HXLINE( 740)		bool _hx_tmp2;
HXDLIN( 740)		bool _hx_tmp3;
HXDLIN( 740)		if (rightDown) {
HXLINE( 740)			_hx_tmp3 = right;
            		}
            		else {
HXLINE( 740)			_hx_tmp3 = false;
            		}
HXDLIN( 740)		if (_hx_tmp3) {
HXLINE( 740)			_hx_tmp2 = down;
            		}
            		else {
HXLINE( 740)			_hx_tmp2 = false;
            		}
HXDLIN( 740)		if (_hx_tmp2) {
HXLINE( 741)			::Array< int > base3 = this->_data;
HXDLIN( 741)			int index4 = index;
HXDLIN( 741)			base3[index4] = (base3->__get(index4) + 8);
            		}
HXLINE( 742)		if (down) {
HXLINE( 743)			::Array< int > base4 = this->_data;
HXDLIN( 743)			int index5 = index;
HXDLIN( 743)			base4[index5] = (base4->__get(index5) + 16);
            		}
HXLINE( 744)		bool _hx_tmp4;
HXDLIN( 744)		bool _hx_tmp5;
HXDLIN( 744)		if (downLeft) {
HXLINE( 744)			_hx_tmp5 = down;
            		}
            		else {
HXLINE( 744)			_hx_tmp5 = false;
            		}
HXDLIN( 744)		if (_hx_tmp5) {
HXLINE( 744)			_hx_tmp4 = left;
            		}
            		else {
HXLINE( 744)			_hx_tmp4 = false;
            		}
HXDLIN( 744)		if (_hx_tmp4) {
HXLINE( 745)			::Array< int > base5 = this->_data;
HXDLIN( 745)			int index6 = index;
HXDLIN( 745)			base5[index6] = (base5->__get(index6) + 32);
            		}
HXLINE( 746)		if (left) {
HXLINE( 747)			::Array< int > base6 = this->_data;
HXDLIN( 747)			int index7 = index;
HXDLIN( 747)			base6[index7] = (base6->__get(index7) + 64);
            		}
HXLINE( 748)		bool _hx_tmp6;
HXDLIN( 748)		bool _hx_tmp7;
HXDLIN( 748)		if (leftUp) {
HXLINE( 748)			_hx_tmp7 = left;
            		}
            		else {
HXLINE( 748)			_hx_tmp7 = false;
            		}
HXDLIN( 748)		if (_hx_tmp7) {
HXLINE( 748)			_hx_tmp6 = up;
            		}
            		else {
HXLINE( 748)			_hx_tmp6 = false;
            		}
HXDLIN( 748)		if (_hx_tmp6) {
HXLINE( 749)			::Array< int > base7 = this->_data;
HXDLIN( 749)			int index8 = index;
HXDLIN( 749)			base7[index8] = (base7->__get(index8) + 128);
            		}
HXLINE( 751)		::Array< int > base8 = this->_data;
HXDLIN( 751)		int index9 = index;
HXDLIN( 751)		base8[index9] = (base8->__get(index9) - (::flixel::tile::FlxBaseTilemap_obj::offsetAutoTile->__get(this->_data->__get(index)) - 1));
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,autoTileFull,(void))

void FlxBaseTilemap_obj::setCustomTileMappings(::Array< int > mappings,::Array< int > randomIndices,::Array< ::Dynamic> randomChoices, ::Dynamic randomLambda){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_764_setCustomTileMappings)
HXLINE( 765)		this->customTileRemap = mappings;
HXLINE( 766)		this->_randomIndices = randomIndices;
HXLINE( 767)		this->_randomChoices = randomChoices;
HXLINE( 768)		this->_randomLambda = randomLambda;
HXLINE( 771)		bool _hx_tmp;
HXDLIN( 771)		if (::hx::IsNotNull( this->_randomIndices )) {
HXLINE( 771)			if (::hx::IsNotNull( this->_randomChoices )) {
HXLINE( 771)				_hx_tmp = (this->_randomChoices->length == 0);
            			}
            			else {
HXLINE( 771)				_hx_tmp = true;
            			}
            		}
            		else {
HXLINE( 771)			_hx_tmp = false;
            		}
HXDLIN( 771)		if (_hx_tmp) {
HXLINE( 773)			HX_STACK_DO_THROW(HX_("You must provide valid 'randomChoices' if you wish to randomize tilemap indices, please read documentation of 'setCustomTileMappings' function.",b3,ce,50,22));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxBaseTilemap_obj,setCustomTileMappings,(void))

int FlxBaseTilemap_obj::getMapIndexAt(Float worldX,Float worldY){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_816_getMapIndexAt)
HXDLIN( 816)		int column = this->getColumnAt(worldX,null());
HXDLIN( 816)		int row = this->getRowAt(worldY,null());
HXDLIN( 816)		bool _hx_tmp;
HXDLIN( 816)		bool _hx_tmp1;
HXDLIN( 816)		if ((column >= 0)) {
HXDLIN( 816)			_hx_tmp1 = (column < this->widthInTiles);
            		}
            		else {
HXDLIN( 816)			_hx_tmp1 = false;
            		}
HXDLIN( 816)		if (_hx_tmp1) {
HXDLIN( 816)			if ((row >= 0)) {
HXDLIN( 816)				_hx_tmp = (row < this->heightInTiles);
            			}
            			else {
HXDLIN( 816)				_hx_tmp = false;
            			}
            		}
            		else {
HXDLIN( 816)			_hx_tmp = false;
            		}
HXDLIN( 816)		if (_hx_tmp) {
HXDLIN( 816)			return ((row * this->widthInTiles) + column);
            		}
            		else {
HXDLIN( 816)			return -1;
            		}
HXDLIN( 816)		return 0;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxBaseTilemap_obj,getMapIndexAt,return )

int FlxBaseTilemap_obj::getColumn(int mapIndex){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_826_getColumn)
HXDLIN( 826)		return ::hx::Mod(mapIndex,this->widthInTiles);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,getColumn,return )

int FlxBaseTilemap_obj::getRow(int mapIndex){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_837_getRow)
HXDLIN( 837)		return ::Std_obj::_hx_int((( (Float)(mapIndex) ) / ( (Float)(this->widthInTiles) )));
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,getRow,return )

bool FlxBaseTilemap_obj::tileExistsAt(Float worldX,Float worldY){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_885_tileExistsAt)
HXDLIN( 885)		int column = this->getColumnAt(worldX,null());
HXDLIN( 885)		bool _hx_tmp;
HXDLIN( 885)		if ((column >= 0)) {
HXDLIN( 885)			_hx_tmp = (column < this->widthInTiles);
            		}
            		else {
HXDLIN( 885)			_hx_tmp = false;
            		}
HXDLIN( 885)		if (_hx_tmp) {
HXDLIN( 885)			int row = this->getRowAt(worldY,null());
HXDLIN( 885)			if ((row >= 0)) {
HXDLIN( 885)				return (row < this->heightInTiles);
            			}
            			else {
HXDLIN( 885)				return false;
            			}
            		}
            		else {
HXDLIN( 885)			return false;
            		}
HXDLIN( 885)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxBaseTilemap_obj,tileExistsAt,return )

bool FlxBaseTilemap_obj::columnExistsAt(Float worldX){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_907_columnExistsAt)
HXDLIN( 907)		int column = this->getColumnAt(worldX,null());
HXDLIN( 907)		if ((column >= 0)) {
HXDLIN( 907)			return (column < this->widthInTiles);
            		}
            		else {
HXDLIN( 907)			return false;
            		}
HXDLIN( 907)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,columnExistsAt,return )

bool FlxBaseTilemap_obj::rowExistsAt(Float worldY){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_929_rowExistsAt)
HXDLIN( 929)		int row = this->getRowAt(worldY,null());
HXDLIN( 929)		if ((row >= 0)) {
HXDLIN( 929)			return (row < this->heightInTiles);
            		}
            		else {
HXDLIN( 929)			return false;
            		}
HXDLIN( 929)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,rowExistsAt,return )

int FlxBaseTilemap_obj::getTileIndexAt(Float worldX,Float worldY){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1046_getTileIndexAt)
HXDLIN(1046)		int column = this->getColumnAt(worldX,null());
HXDLIN(1046)		int row = this->getRowAt(worldY,null());
HXDLIN(1046)		int mapIndex;
HXDLIN(1046)		bool mapIndex1;
HXDLIN(1046)		bool mapIndex2;
HXDLIN(1046)		if ((column >= 0)) {
HXDLIN(1046)			mapIndex2 = (column < this->widthInTiles);
            		}
            		else {
HXDLIN(1046)			mapIndex2 = false;
            		}
HXDLIN(1046)		if (mapIndex2) {
HXDLIN(1046)			if ((row >= 0)) {
HXDLIN(1046)				mapIndex1 = (row < this->heightInTiles);
            			}
            			else {
HXDLIN(1046)				mapIndex1 = false;
            			}
            		}
            		else {
HXDLIN(1046)			mapIndex1 = false;
            		}
HXDLIN(1046)		if (mapIndex1) {
HXDLIN(1046)			mapIndex = ((row * this->widthInTiles) + column);
            		}
            		else {
HXDLIN(1046)			mapIndex = -1;
            		}
HXDLIN(1046)		bool _hx_tmp;
HXDLIN(1046)		if ((mapIndex >= 0)) {
HXDLIN(1046)			_hx_tmp = (mapIndex < this->_data->length);
            		}
            		else {
HXDLIN(1046)			_hx_tmp = false;
            		}
HXDLIN(1046)		if (_hx_tmp) {
HXDLIN(1046)			return this->_data->__get(mapIndex);
            		}
            		else {
HXDLIN(1046)			return -1;
            		}
HXDLIN(1046)		return 0;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxBaseTilemap_obj,getTileIndexAt,return )

 ::flixel::math::FlxBasePoint FlxBaseTilemap_obj::getTilePosAt(Float worldX,Float worldY,::hx::Null< bool >  __o_midpoint){
            		bool midpoint = __o_midpoint.Default(false);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1112_getTilePosAt)
HXDLIN(1112)		int column = this->getColumnAt(worldX,null());
HXDLIN(1112)		int row = this->getRowAt(worldY,null());
HXDLIN(1112)		Float x = this->getColumnPos(( (Float)(column) ),midpoint);
HXDLIN(1112)		Float y = this->getRowPos(row,midpoint);
HXDLIN(1112)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(x,y);
HXDLIN(1112)		point->_inPool = false;
HXDLIN(1112)		return point;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxBaseTilemap_obj,getTilePosAt,return )

::Array< ::Dynamic> FlxBaseTilemap_obj::getAllTilePos(int tileIndex,::hx::Null< bool >  __o_midpoint){
            		bool midpoint = __o_midpoint.Default(false);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1124_getAllTilePos)
HXLINE(1125)		::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(1127)		int length = this->_data->length;
HXLINE(1128)		{
HXLINE(1128)			int _g = 0;
HXDLIN(1128)			int _g1 = length;
HXDLIN(1128)			while((_g < _g1)){
HXLINE(1128)				_g = (_g + 1);
HXDLIN(1128)				int mapIndex = (_g - 1);
HXLINE(1130)				int _hx_tmp;
HXDLIN(1130)				bool _hx_tmp1;
HXDLIN(1130)				if ((mapIndex >= 0)) {
HXLINE(1130)					_hx_tmp1 = (mapIndex < this->_data->length);
            				}
            				else {
HXLINE(1130)					_hx_tmp1 = false;
            				}
HXDLIN(1130)				if (_hx_tmp1) {
HXLINE(1130)					_hx_tmp = this->_data->__get(mapIndex);
            				}
            				else {
HXLINE(1130)					_hx_tmp = -1;
            				}
HXDLIN(1130)				if ((_hx_tmp == tileIndex)) {
HXLINE(1132)					 ::flixel::math::FlxBasePoint _hx_tmp2;
HXDLIN(1132)					bool _hx_tmp3;
HXDLIN(1132)					if ((mapIndex >= 0)) {
HXLINE(1132)						_hx_tmp3 = (mapIndex < this->_data->length);
            					}
            					else {
HXLINE(1132)						_hx_tmp3 = false;
            					}
HXDLIN(1132)					if (_hx_tmp3) {
HXLINE(1132)						int column = ::hx::Mod(mapIndex,this->widthInTiles);
HXDLIN(1132)						int row = ::Std_obj::_hx_int((( (Float)(mapIndex) ) / ( (Float)(this->widthInTiles) )));
HXDLIN(1132)						Float x = this->getColumnPos(( (Float)(column) ),midpoint);
HXDLIN(1132)						Float y = this->getRowPos(row,midpoint);
HXDLIN(1132)						 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(x,y);
HXDLIN(1132)						point->_inPool = false;
HXDLIN(1132)						_hx_tmp2 = point;
            					}
            					else {
HXLINE(1132)						_hx_tmp2 = null();
            					}
HXDLIN(1132)					result->push(_hx_tmp2);
            				}
            			}
            		}
HXLINE(1135)		return result;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxBaseTilemap_obj,getAllTilePos,return )

int FlxBaseTilemap_obj::getTile(int column,int row){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1148_getTile)
HXDLIN(1148)		int mapIndex;
HXDLIN(1148)		bool mapIndex1;
HXDLIN(1148)		bool mapIndex2;
HXDLIN(1148)		if ((column >= 0)) {
HXDLIN(1148)			mapIndex2 = (column < this->widthInTiles);
            		}
            		else {
HXDLIN(1148)			mapIndex2 = false;
            		}
HXDLIN(1148)		if (mapIndex2) {
HXDLIN(1148)			if ((row >= 0)) {
HXDLIN(1148)				mapIndex1 = (row < this->heightInTiles);
            			}
            			else {
HXDLIN(1148)				mapIndex1 = false;
            			}
            		}
            		else {
HXDLIN(1148)			mapIndex1 = false;
            		}
HXDLIN(1148)		if (mapIndex1) {
HXDLIN(1148)			mapIndex = ((row * this->widthInTiles) + column);
            		}
            		else {
HXDLIN(1148)			mapIndex = -1;
            		}
HXDLIN(1148)		bool _hx_tmp;
HXDLIN(1148)		if ((mapIndex >= 0)) {
HXDLIN(1148)			_hx_tmp = (mapIndex < this->_data->length);
            		}
            		else {
HXDLIN(1148)			_hx_tmp = false;
            		}
HXDLIN(1148)		if (_hx_tmp) {
HXDLIN(1148)			return this->_data->__get(mapIndex);
            		}
            		else {
HXDLIN(1148)			return -1;
            		}
HXDLIN(1148)		return 0;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxBaseTilemap_obj,getTile,return )

int FlxBaseTilemap_obj::getTileByIndex(int mapIndex){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1162_getTileByIndex)
HXDLIN(1162)		bool _hx_tmp;
HXDLIN(1162)		if ((mapIndex >= 0)) {
HXDLIN(1162)			_hx_tmp = (mapIndex < this->_data->length);
            		}
            		else {
HXDLIN(1162)			_hx_tmp = false;
            		}
HXDLIN(1162)		if (_hx_tmp) {
HXDLIN(1162)			return this->_data->__get(mapIndex);
            		}
            		else {
HXDLIN(1162)			return -1;
            		}
HXDLIN(1162)		return 0;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,getTileByIndex,return )

int FlxBaseTilemap_obj::getTileCollisions(int mapIndex){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1178_getTileCollisions)
HXDLIN(1178)		int _hx_tmp;
HXDLIN(1178)		bool _hx_tmp1;
HXDLIN(1178)		if ((mapIndex >= 0)) {
HXDLIN(1178)			_hx_tmp1 = (mapIndex < this->_data->length);
            		}
            		else {
HXDLIN(1178)			_hx_tmp1 = false;
            		}
HXDLIN(1178)		if (_hx_tmp1) {
HXDLIN(1178)			_hx_tmp = this->_data->__get(mapIndex);
            		}
            		else {
HXDLIN(1178)			_hx_tmp = -1;
            		}
HXDLIN(1178)		return ( ( ::flixel::FlxObject)(this->_tileObjects->__get(_hx_tmp)) )->allowCollisions;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,getTileCollisions,return )

::Array< int > FlxBaseTilemap_obj::getTileInstances(int tileIndex){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1191_getTileInstances)
HXLINE(1193)		::Array< int > result = this->getAllMapIndices(tileIndex);
HXLINE(1194)		if ((result->length == 0)) {
HXLINE(1194)			return null();
            		}
            		else {
HXLINE(1194)			return result;
            		}
HXDLIN(1194)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,getTileInstances,return )

::Array< int > FlxBaseTilemap_obj::getAllMapIndices(int tileIndex){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1207_getAllMapIndices)
HXLINE(1208)		::Array< int > result = ::Array_obj< int >::__new(0);
HXLINE(1210)		int length = this->_data->length;
HXLINE(1211)		{
HXLINE(1211)			int _g = 0;
HXDLIN(1211)			int _g1 = length;
HXDLIN(1211)			while((_g < _g1)){
HXLINE(1211)				_g = (_g + 1);
HXDLIN(1211)				int mapIndex = (_g - 1);
HXLINE(1213)				int _hx_tmp;
HXDLIN(1213)				bool _hx_tmp1;
HXDLIN(1213)				if ((mapIndex >= 0)) {
HXLINE(1213)					_hx_tmp1 = (mapIndex < this->_data->length);
            				}
            				else {
HXLINE(1213)					_hx_tmp1 = false;
            				}
HXDLIN(1213)				if (_hx_tmp1) {
HXLINE(1213)					_hx_tmp = this->_data->__get(mapIndex);
            				}
            				else {
HXLINE(1213)					_hx_tmp = -1;
            				}
HXDLIN(1213)				if ((_hx_tmp == tileIndex)) {
HXLINE(1215)					result->push(mapIndex);
            				}
            			}
            		}
HXLINE(1218)		return result;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,getAllMapIndices,return )

void FlxBaseTilemap_obj::forEachMapIndex(int tileIndex, ::Dynamic f){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1229_forEachMapIndex)
HXLINE(1230)		int length = this->_data->length;
HXLINE(1231)		{
HXLINE(1231)			int _g = 0;
HXDLIN(1231)			int _g1 = length;
HXDLIN(1231)			while((_g < _g1)){
HXLINE(1231)				_g = (_g + 1);
HXDLIN(1231)				int mapIndex = (_g - 1);
HXLINE(1233)				int _hx_tmp;
HXDLIN(1233)				bool _hx_tmp1;
HXDLIN(1233)				if ((mapIndex >= 0)) {
HXLINE(1233)					_hx_tmp1 = (mapIndex < this->_data->length);
            				}
            				else {
HXLINE(1233)					_hx_tmp1 = false;
            				}
HXDLIN(1233)				if (_hx_tmp1) {
HXLINE(1233)					_hx_tmp = this->_data->__get(mapIndex);
            				}
            				else {
HXLINE(1233)					_hx_tmp = -1;
            				}
HXDLIN(1233)				if ((_hx_tmp == tileIndex)) {
HXLINE(1235)					f(mapIndex);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxBaseTilemap_obj,forEachMapIndex,(void))

bool FlxBaseTilemap_obj::setTileIndexAt(Float worldX,Float worldY,int tileIndex,::hx::Null< bool >  __o_redraw){
            		bool redraw = __o_redraw.Default(true);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1295_setTileIndexAt)
HXDLIN(1295)		int column = this->getColumnAt(worldX,null());
HXDLIN(1295)		int row = this->getRowAt(worldY,null());
HXDLIN(1295)		int _hx_tmp;
HXDLIN(1295)		bool _hx_tmp1;
HXDLIN(1295)		bool _hx_tmp2;
HXDLIN(1295)		if ((column >= 0)) {
HXDLIN(1295)			_hx_tmp2 = (column < this->widthInTiles);
            		}
            		else {
HXDLIN(1295)			_hx_tmp2 = false;
            		}
HXDLIN(1295)		if (_hx_tmp2) {
HXDLIN(1295)			if ((row >= 0)) {
HXDLIN(1295)				_hx_tmp1 = (row < this->heightInTiles);
            			}
            			else {
HXDLIN(1295)				_hx_tmp1 = false;
            			}
            		}
            		else {
HXDLIN(1295)			_hx_tmp1 = false;
            		}
HXDLIN(1295)		if (_hx_tmp1) {
HXDLIN(1295)			_hx_tmp = ((row * this->widthInTiles) + column);
            		}
            		else {
HXDLIN(1295)			_hx_tmp = -1;
            		}
HXDLIN(1295)		return this->setTileHelper(_hx_tmp,tileIndex,redraw);
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxBaseTilemap_obj,setTileIndexAt,return )

bool FlxBaseTilemap_obj::setTile(int column,int row,int tileIndex,::hx::Null< bool >  __o_redraw){
            		bool redraw = __o_redraw.Default(true);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1310_setTile)
HXDLIN(1310)		int mapIndex;
HXDLIN(1310)		bool mapIndex1;
HXDLIN(1310)		bool mapIndex2;
HXDLIN(1310)		if ((column >= 0)) {
HXDLIN(1310)			mapIndex2 = (column < this->widthInTiles);
            		}
            		else {
HXDLIN(1310)			mapIndex2 = false;
            		}
HXDLIN(1310)		if (mapIndex2) {
HXDLIN(1310)			if ((row >= 0)) {
HXDLIN(1310)				mapIndex1 = (row < this->heightInTiles);
            			}
            			else {
HXDLIN(1310)				mapIndex1 = false;
            			}
            		}
            		else {
HXDLIN(1310)			mapIndex1 = false;
            		}
HXDLIN(1310)		if (mapIndex1) {
HXDLIN(1310)			mapIndex = ((row * this->widthInTiles) + column);
            		}
            		else {
HXDLIN(1310)			mapIndex = -1;
            		}
HXDLIN(1310)		return this->setTileHelper(mapIndex,tileIndex,redraw);
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxBaseTilemap_obj,setTile,return )

bool FlxBaseTilemap_obj::setTileByIndex(int mapIndex,int tileIndex,::hx::Null< bool >  __o_redraw){
            		bool redraw = __o_redraw.Default(true);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1324_setTileByIndex)
HXDLIN(1324)		return this->setTileHelper(mapIndex,tileIndex,redraw);
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxBaseTilemap_obj,setTileByIndex,return )

bool FlxBaseTilemap_obj::setTileHelper(int mapIndex,int tileIndex,::hx::Null< bool >  __o_redraw){
            		bool redraw = __o_redraw.Default(true);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1328_setTileHelper)
HXLINE(1329)		bool _hx_tmp;
HXDLIN(1329)		if ((mapIndex >= 0)) {
HXLINE(1329)			_hx_tmp = (mapIndex < this->_data->length);
            		}
            		else {
HXLINE(1329)			_hx_tmp = false;
            		}
HXDLIN(1329)		if (!(_hx_tmp)) {
HXLINE(1330)			return false;
            		}
HXLINE(1332)		this->_data[mapIndex] = tileIndex;
HXLINE(1334)		if (!(redraw)) {
HXLINE(1336)			return true;
            		}
HXLINE(1339)		this->setDirty(null());
HXLINE(1341)		if ((this->_hx_auto->_hx_getIndex() == 0)) {
HXLINE(1344)			this->updateTile(this->_data->__get(mapIndex));
            		}
            		else {
HXLINE(1346)			this->updateTileWithAutoTile(mapIndex);
            		}
HXLINE(1349)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxBaseTilemap_obj,setTileHelper,return )

void FlxBaseTilemap_obj::updateTileWithAutoTile(int mapIndex){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1353_updateTileWithAutoTile)
HXLINE(1355)		int row = (::Std_obj::_hx_int((( (Float)(mapIndex) ) / ( (Float)(this->widthInTiles) ))) - 1);
HXLINE(1356)		int column = (::hx::Mod(mapIndex,this->widthInTiles) - 1);
HXLINE(1357)		int rowLength = (row + 3);
HXLINE(1358)		int columnHeight = (column + 3);
HXLINE(1360)		while((row < rowLength)){
HXLINE(1362)			column = (columnHeight - 3);
HXLINE(1364)			while((column < columnHeight)){
HXLINE(1366)				bool _hx_tmp;
HXDLIN(1366)				bool _hx_tmp1;
HXDLIN(1366)				if ((column >= 0)) {
HXLINE(1366)					_hx_tmp1 = (column < this->widthInTiles);
            				}
            				else {
HXLINE(1366)					_hx_tmp1 = false;
            				}
HXDLIN(1366)				if (_hx_tmp1) {
HXLINE(1366)					if ((row >= 0)) {
HXLINE(1366)						_hx_tmp = (row < this->heightInTiles);
            					}
            					else {
HXLINE(1366)						_hx_tmp = false;
            					}
            				}
            				else {
HXLINE(1366)					_hx_tmp = false;
            				}
HXDLIN(1366)				if (_hx_tmp) {
HXLINE(1368)					int i;
HXDLIN(1368)					bool i1;
HXDLIN(1368)					bool i2;
HXDLIN(1368)					if ((column >= 0)) {
HXLINE(1368)						i2 = (column < this->widthInTiles);
            					}
            					else {
HXLINE(1368)						i2 = false;
            					}
HXDLIN(1368)					if (i2) {
HXLINE(1368)						if ((row >= 0)) {
HXLINE(1368)							i1 = (row < this->heightInTiles);
            						}
            						else {
HXLINE(1368)							i1 = false;
            						}
            					}
            					else {
HXLINE(1368)						i1 = false;
            					}
HXDLIN(1368)					if (i1) {
HXLINE(1368)						i = ((row * this->widthInTiles) + column);
            					}
            					else {
HXLINE(1368)						i = -1;
            					}
HXLINE(1369)					this->autoTile(i);
HXLINE(1370)					this->updateTile(this->_data->__get(i));
            				}
HXLINE(1372)				column = (column + 1);
            			}
HXLINE(1374)			row = (row + 1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,updateTileWithAutoTile,(void))

void FlxBaseTilemap_obj::setTileProperties(int tile,::hx::Null< int >  __o_allowCollisions, ::Dynamic callback,::hx::Class callbackFilter,::hx::Null< int >  __o_range){
            		int allowCollisions = __o_allowCollisions.Default(4369);
            		int range = __o_range.Default(1);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1389_setTileProperties)
HXLINE(1390)		if ((range <= 0)) {
HXLINE(1392)			range = 1;
            		}
HXLINE(1395)		int maxIndex = this->_tileObjects->get_length();
HXLINE(1396)		int end = (tile + range);
HXLINE(1397)		if ((maxIndex == 0)) {
HXLINE(1399)			::String rangeDisplay;
HXDLIN(1399)			if ((range == 1)) {
HXLINE(1399)				rangeDisplay = (HX_("tile ",32,fd,34,10) + tile);
            			}
            			else {
HXLINE(1399)				rangeDisplay = (((HX_("tiles ",fb,d6,28,1e) + tile) + HX_("-",2d,00,00,00)) + (end - 1));
            			}
HXLINE(1400)			::flixel::FlxG_obj::log->advanced((((HX_("Cannot setTileProperties of ",cf,3d,52,94) + rangeDisplay) + HX_(" when tilemap does not contain any tiles.",c5,3c,2f,55)) + HX_(" This may be due to an invalid graphic.",a9,75,60,06)),::flixel::_hx_system::debug::log::LogStyle_obj::ERROR,true,::hx::SourceInfo(HX_("flixel/tile/FlxBaseTilemap.hx",e5,d8,39,01),1400,HX_("flixel.tile.FlxBaseTilemap",19,d7,a6,6a),HX_("setTileProperties",03,58,a1,54)));
HXLINE(1402)			return;
            		}
HXLINE(1405)		if ((end > maxIndex)) {
HXLINE(1407)			::String rangeDisplay1;
HXDLIN(1407)			if ((range == 1)) {
HXLINE(1407)				rangeDisplay1 = (HX_("tile ",32,fd,34,10) + tile);
            			}
            			else {
HXLINE(1407)				rangeDisplay1 = (((HX_("tiles ",fb,d6,28,1e) + tile) + HX_("-",2d,00,00,00)) + (end - 1));
            			}
HXLINE(1408)			::flixel::FlxG_obj::log->advanced(((((HX_("Cannot setTileProperties of ",cf,3d,52,94) + rangeDisplay1) + HX_(" when there are only ",66,4c,3f,59)) + end) + HX_(" tiles.",29,af,d7,50)),::flixel::_hx_system::debug::log::LogStyle_obj::ERROR,true,::hx::SourceInfo(HX_("flixel/tile/FlxBaseTilemap.hx",e5,d8,39,01),1408,HX_("flixel.tile.FlxBaseTilemap",19,d7,a6,6a),HX_("setTileProperties",03,58,a1,54)));
HXLINE(1409)			return;
            		}
HXLINE(1412)		{
HXLINE(1412)			int _g = tile;
HXDLIN(1412)			int _g1 = end;
HXDLIN(1412)			while((_g < _g1)){
HXLINE(1412)				_g = (_g + 1);
HXDLIN(1412)				int i = (_g - 1);
HXLINE(1414)				 ::Dynamic tileData = this->_tileObjects->__get(i);
HXLINE(1415)				( ( ::flixel::FlxObject)(tileData) )->set_allowCollisions(allowCollisions);
HXLINE(1416)				tileData->__SetField(HX_("callbackFunction",fd,cd,91,7e),callback,::hx::paccDynamic);
HXLINE(1417)				tileData->__SetField(HX_("filter",b8,1f,35,85),callbackFilter,::hx::paccDynamic);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(FlxBaseTilemap_obj,setTileProperties,(void))

::Array< int > FlxBaseTilemap_obj::getData(::hx::Null< bool >  __o_simple){
            		bool simple = __o_simple.Default(false);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1429_getData)
HXLINE(1430)		if (!(simple)) {
HXLINE(1431)			return this->_data;
            		}
HXLINE(1434)		::Array< int > _g = ::Array_obj< int >::__new(0);
HXLINE(1435)		{
HXLINE(1435)			int _g1 = 0;
HXDLIN(1435)			int _g2 = this->_data->length;
HXDLIN(1435)			while((_g1 < _g2)){
HXLINE(1435)				_g1 = (_g1 + 1);
HXDLIN(1435)				int i = (_g1 - 1);
HXLINE(1436)				int _hx_tmp;
HXDLIN(1436)				int _hx_tmp1;
HXDLIN(1436)				bool _hx_tmp2;
HXDLIN(1436)				if ((i >= 0)) {
HXLINE(1436)					_hx_tmp2 = (i < this->_data->length);
            				}
            				else {
HXLINE(1436)					_hx_tmp2 = false;
            				}
HXDLIN(1436)				if (_hx_tmp2) {
HXLINE(1436)					_hx_tmp1 = this->_data->__get(i);
            				}
            				else {
HXLINE(1436)					_hx_tmp1 = -1;
            				}
HXDLIN(1436)				if (((( ( ::flixel::FlxObject)(this->_tileObjects->__get(_hx_tmp1)) )->allowCollisions & 4369) > 0)) {
HXLINE(1436)					_hx_tmp = 1;
            				}
            				else {
HXLINE(1436)					_hx_tmp = 0;
            				}
HXDLIN(1436)				_g->push(_hx_tmp);
            			}
            		}
HXLINE(1434)		return _g;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,getData,return )

::Array< ::Dynamic> FlxBaseTilemap_obj::findPath( ::flixel::math::FlxBasePoint start, ::flixel::math::FlxBasePoint end, ::flixel::path::FlxPathSimplifier __o_simplify,::hx::Null< int >  __o_diagonalPolicy){
            		 ::flixel::path::FlxPathSimplifier simplify = __o_simplify;
            		if (::hx::IsNull(__o_simplify)) simplify = ::flixel::path::FlxPathSimplifier_obj::LINE_dyn();
            		int diagonalPolicy = __o_diagonalPolicy.Default(2);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1458_findPath)
HXDLIN(1458)		::flixel::tile::FlxBaseTilemap_obj::diagonalPathfinder->diagonalPolicy = diagonalPolicy;
HXDLIN(1458)		return ( ( ::flixel::path::FlxTypedPathfinder)(::flixel::tile::FlxBaseTilemap_obj::diagonalPathfinder) )->findPath(::hx::ObjectPtr<OBJ_>(this),start,end,simplify);
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxBaseTilemap_obj,findPath,return )

::Array< ::Dynamic> FlxBaseTilemap_obj::findPathCustom( ::flixel::path::FlxTypedPathfinder pathfinder, ::flixel::math::FlxBasePoint start, ::flixel::math::FlxBasePoint end, ::flixel::path::FlxPathSimplifier __o_simplify){
            		 ::flixel::path::FlxPathSimplifier simplify = __o_simplify;
            		if (::hx::IsNull(__o_simplify)) simplify = ::flixel::path::FlxPathSimplifier_obj::LINE_dyn();
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1480_findPathCustom)
HXDLIN(1480)		return pathfinder->findPath(::hx::ObjectPtr<OBJ_>(this),start,end,simplify);
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxBaseTilemap_obj,findPathCustom,return )

::Array< int > FlxBaseTilemap_obj::computePathDistance(int startIndex,int endIndex,::hx::Null< int >  __o_diagonalPolicy,::hx::Null< bool >  __o_stopOnEnd){
            		int diagonalPolicy = __o_diagonalPolicy.Default(2);
            		bool stopOnEnd = __o_stopOnEnd.Default(true);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1494_computePathDistance)
HXLINE(1495)		 ::flixel::path::FlxTypedPathfinderData data = this->computePathData(startIndex,endIndex,diagonalPolicy,stopOnEnd);
HXLINE(1496)		if (::hx::IsNotNull( data )) {
HXLINE(1497)			return data->distances;
            		}
HXLINE(1499)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxBaseTilemap_obj,computePathDistance,return )

 ::flixel::path::FlxTypedPathfinderData FlxBaseTilemap_obj::computePathData(int startIndex,int endIndex,::hx::Null< int >  __o_diagonalPolicy,::hx::Null< bool >  __o_stopOnEnd){
            		int diagonalPolicy = __o_diagonalPolicy.Default(2);
            		bool stopOnEnd = __o_stopOnEnd.Default(true);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1516_computePathData)
HXDLIN(1516)		::flixel::tile::FlxBaseTilemap_obj::diagonalPathfinder->diagonalPolicy = diagonalPolicy;
HXDLIN(1516)		 ::flixel::path::FlxTypedPathfinder _this = ( ( ::flixel::path::FlxTypedPathfinder)(::flixel::tile::FlxBaseTilemap_obj::diagonalPathfinder) );
HXDLIN(1516)		return _this->compute(_this->createData(::hx::ObjectPtr<OBJ_>(this),startIndex,endIndex),stopOnEnd).StaticCast<  ::flixel::path::FlxTypedPathfinderData >();
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxBaseTilemap_obj,computePathData,return )

 ::flixel::path::FlxTypedPathfinder FlxBaseTilemap_obj::getDiagonalPathfinder(int diagonalPolicy){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1520_getDiagonalPathfinder)
HXLINE(1521)		::flixel::tile::FlxBaseTilemap_obj::diagonalPathfinder->diagonalPolicy = diagonalPolicy;
HXLINE(1522)		return ::flixel::tile::FlxBaseTilemap_obj::diagonalPathfinder;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,getDiagonalPathfinder,return )

bool FlxBaseTilemap_obj::overlaps( ::flixel::FlxBasic objectOrGroup,::hx::Null< bool >  __o_inScreenSpace, ::flixel::FlxCamera camera){
            		bool inScreenSpace = __o_inScreenSpace.Default(false);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1537_overlaps)
HXLINE(1538)		 ::flixel::group::FlxTypedGroup group = ::flixel::group::FlxTypedGroup_obj::resolveGroup(objectOrGroup);
HXLINE(1539)		if (::hx::IsNotNull( group )) {
            			HX_BEGIN_LOCAL_FUNC_S3(::hx::LocalFunc,_hx_Closure_0, ::flixel::tile::FlxBaseTilemap,_g,bool,inScreenSpace1, ::flixel::FlxCamera,camera1) HXARGC(1)
            			bool _hx_run( ::flixel::FlxBasic objectOrGroup){
            				HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1540_overlaps)
HXLINE(1540)				bool _hx_tmp;
HXDLIN(1540)				if ((objectOrGroup->flixelType != 1)) {
HXLINE(1540)					_hx_tmp = (objectOrGroup->flixelType == 3);
            				}
            				else {
HXLINE(1540)					_hx_tmp = true;
            				}
HXDLIN(1540)				if (_hx_tmp) {
HXLINE(1540)					return _g->objectOverlapsTiles(( ( ::flixel::FlxObject)(objectOrGroup) ),null(),null(),null());
            				}
            				else {
HXLINE(1540)					return _g->overlaps(objectOrGroup,inScreenSpace1,camera1);
            				}
HXDLIN(1540)				return false;
            			}
            			HX_END_LOCAL_FUNC1(return)

HXLINE(1540)			 ::flixel::tile::FlxBaseTilemap _g = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN(1540)			Float x = ( (Float)(0) );
HXDLIN(1540)			Float y = ( (Float)(0) );
HXDLIN(1540)			bool inScreenSpace1 = inScreenSpace;
HXDLIN(1540)			 ::flixel::FlxCamera camera1 = camera;
HXDLIN(1540)			return group->any( ::Dynamic(new _hx_Closure_0(_g,inScreenSpace1,camera1)));
            		}
HXLINE(1542)		 ::flixel::FlxCamera camera2 = null();
HXDLIN(1542)		bool _hx_tmp;
HXDLIN(1542)		if ((objectOrGroup->flixelType != 1)) {
HXLINE(1542)			_hx_tmp = (objectOrGroup->flixelType == 3);
            		}
            		else {
HXLINE(1542)			_hx_tmp = true;
            		}
HXDLIN(1542)		if (_hx_tmp) {
HXLINE(1542)			return this->objectOverlapsTiles(( ( ::flixel::FlxObject)(objectOrGroup) ),null(),null(),null());
            		}
            		else {
HXLINE(1542)			return this->overlaps(objectOrGroup,false,camera2);
            		}
HXDLIN(1542)		return false;
            	}


bool FlxBaseTilemap_obj::tilemapOverlapsCallback( ::flixel::FlxBasic objectOrGroup,::hx::Null< Float >  __o_x,::hx::Null< Float >  __o_y,::hx::Null< bool >  __o_inScreenSpace, ::flixel::FlxCamera camera){
            		Float x = __o_x.Default(((Float)0.0));
            		Float y = __o_y.Default(((Float)0.0));
            		bool inScreenSpace = __o_inScreenSpace.Default(false);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1547_tilemapOverlapsCallback)
HXDLIN(1547)		bool _hx_tmp;
HXDLIN(1547)		if ((objectOrGroup->flixelType != 1)) {
HXDLIN(1547)			_hx_tmp = (objectOrGroup->flixelType == 3);
            		}
            		else {
HXDLIN(1547)			_hx_tmp = true;
            		}
HXDLIN(1547)		if (_hx_tmp) {
HXLINE(1549)			return this->objectOverlapsTiles(( ( ::flixel::FlxObject)(objectOrGroup) ),null(),null(),null());
            		}
            		else {
HXLINE(1553)			return this->overlaps(objectOrGroup,inScreenSpace,camera);
            		}
HXLINE(1547)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC5(FlxBaseTilemap_obj,tilemapOverlapsCallback,return )

bool FlxBaseTilemap_obj::overlapsAt(Float x,Float y, ::flixel::FlxBasic objectOrGroup,::hx::Null< bool >  __o_inScreenSpace, ::flixel::FlxCamera camera){
            		bool inScreenSpace = __o_inScreenSpace.Default(false);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1571_overlapsAt)
HXLINE(1572)		 ::flixel::group::FlxTypedGroup group = ::flixel::group::FlxTypedGroup_obj::resolveGroup(objectOrGroup);
HXLINE(1573)		if (::hx::IsNotNull( group )) {
            			HX_BEGIN_LOCAL_FUNC_S5(::hx::LocalFunc,_hx_Closure_0,Float,y1,Float,x1, ::flixel::tile::FlxBaseTilemap,_g,bool,inScreenSpace1, ::flixel::FlxCamera,camera1) HXARGC(1)
            			bool _hx_run( ::flixel::FlxBasic objectOrGroup){
            				HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1574_overlapsAt)
HXLINE(1574)				bool _hx_tmp;
HXDLIN(1574)				if ((objectOrGroup->flixelType != 1)) {
HXLINE(1574)					_hx_tmp = (objectOrGroup->flixelType == 3);
            				}
            				else {
HXLINE(1574)					_hx_tmp = true;
            				}
HXDLIN(1574)				if (_hx_tmp) {
HXLINE(1574)					 ::flixel::tile::FlxBaseTilemap _g1 = _g;
HXDLIN(1574)					 ::flixel::math::FlxBasePoint this1 = _g->_point;
HXDLIN(1574)					this1->set_x(x1);
HXDLIN(1574)					this1->set_y(y1);
HXDLIN(1574)					return _g1->objectOverlapsTiles(( ( ::flixel::FlxObject)(objectOrGroup) ),null(),this1,null());
            				}
            				else {
HXLINE(1574)					return _g->overlapsAt(x1,y1,objectOrGroup,inScreenSpace1,camera1);
            				}
HXDLIN(1574)				return false;
            			}
            			HX_END_LOCAL_FUNC1(return)

HXLINE(1574)			 ::flixel::tile::FlxBaseTilemap _g = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN(1574)			Float x1 = x;
HXDLIN(1574)			Float y1 = y;
HXDLIN(1574)			bool inScreenSpace1 = inScreenSpace;
HXDLIN(1574)			 ::flixel::FlxCamera camera1 = camera;
HXDLIN(1574)			return group->any( ::Dynamic(new _hx_Closure_0(y1,x1,_g,inScreenSpace1,camera1)));
            		}
HXLINE(1576)		bool _hx_tmp;
HXDLIN(1576)		if ((objectOrGroup->flixelType != 1)) {
HXLINE(1576)			_hx_tmp = (objectOrGroup->flixelType == 3);
            		}
            		else {
HXLINE(1576)			_hx_tmp = true;
            		}
HXDLIN(1576)		if (_hx_tmp) {
HXLINE(1576)			 ::flixel::math::FlxBasePoint this1 = this->_point;
HXDLIN(1576)			this1->set_x(x);
HXDLIN(1576)			this1->set_y(y);
HXDLIN(1576)			return this->objectOverlapsTiles(( ( ::flixel::FlxObject)(objectOrGroup) ),null(),this1,null());
            		}
            		else {
HXLINE(1576)			return this->overlapsAt(x,y,objectOrGroup,inScreenSpace,camera);
            		}
HXDLIN(1576)		return false;
            	}


bool FlxBaseTilemap_obj::tilemapOverlapsAtCallback( ::flixel::FlxBasic objectOrGroup,Float x,Float y,bool inScreenSpace, ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1581_tilemapOverlapsAtCallback)
HXDLIN(1581)		bool _hx_tmp;
HXDLIN(1581)		if ((objectOrGroup->flixelType != 1)) {
HXDLIN(1581)			_hx_tmp = (objectOrGroup->flixelType == 3);
            		}
            		else {
HXDLIN(1581)			_hx_tmp = true;
            		}
HXDLIN(1581)		if (_hx_tmp) {
HXLINE(1583)			 ::flixel::math::FlxBasePoint this1 = this->_point;
HXDLIN(1583)			this1->set_x(x);
HXDLIN(1583)			this1->set_y(y);
HXDLIN(1583)			return this->objectOverlapsTiles(( ( ::flixel::FlxObject)(objectOrGroup) ),null(),this1,null());
            		}
            		else {
HXLINE(1587)			return this->overlapsAt(x,y,objectOrGroup,inScreenSpace,camera);
            		}
HXLINE(1581)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC5(FlxBaseTilemap_obj,tilemapOverlapsAtCallback,return )

bool FlxBaseTilemap_obj::overlapsPoint( ::flixel::math::FlxBasePoint worldPoint,::hx::Null< bool >  __o_inScreenSpace, ::flixel::FlxCamera camera){
            		bool inScreenSpace = __o_inScreenSpace.Default(false);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1600_overlapsPoint)
HXLINE(1601)		if (inScreenSpace) {
HXLINE(1603)			if (::hx::IsNull( camera )) {
HXLINE(1604)				camera = this->getDefaultCamera();
            			}
HXLINE(1606)			{
HXLINE(1606)				 ::flixel::math::FlxBasePoint point = camera->scroll;
HXDLIN(1606)				{
HXLINE(1606)					Float y = point->y;
HXDLIN(1606)					worldPoint->set_x((worldPoint->x - point->x));
HXDLIN(1606)					worldPoint->set_y((worldPoint->y - y));
            				}
HXDLIN(1606)				{
HXLINE(1606)					 ::flixel::math::FlxBasePoint _this = point;
HXDLIN(1606)					if (_this->_weak) {
HXLINE(1606)						_this->put();
            					}
            				}
            			}
HXLINE(1607)			{
HXLINE(1607)				 ::flixel::math::FlxBasePoint _this1 = worldPoint;
HXDLIN(1607)				if (_this1->_weak) {
HXLINE(1607)					_this1->put();
            				}
            			}
            		}
HXLINE(1610)		return this->tileAtPointAllowsCollisions(worldPoint);
            	}


bool FlxBaseTilemap_obj::tileAtPointAllowsCollisions( ::flixel::math::FlxBasePoint point){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1614_tileAtPointAllowsCollisions)
HXLINE(1615)		Float worldY = point->y;
HXDLIN(1615)		int column = this->getColumnAt(point->x,null());
HXDLIN(1615)		int row = this->getRowAt(worldY,null());
HXDLIN(1615)		int mapIndex;
HXDLIN(1615)		bool mapIndex1;
HXDLIN(1615)		bool mapIndex2;
HXDLIN(1615)		if ((column >= 0)) {
HXLINE(1615)			mapIndex2 = (column < this->widthInTiles);
            		}
            		else {
HXLINE(1615)			mapIndex2 = false;
            		}
HXDLIN(1615)		if (mapIndex2) {
HXLINE(1615)			if ((row >= 0)) {
HXLINE(1615)				mapIndex1 = (row < this->heightInTiles);
            			}
            			else {
HXLINE(1615)				mapIndex1 = false;
            			}
            		}
            		else {
HXLINE(1615)			mapIndex1 = false;
            		}
HXDLIN(1615)		if (mapIndex1) {
HXLINE(1615)			mapIndex = ((row * this->widthInTiles) + column);
            		}
            		else {
HXLINE(1615)			mapIndex = -1;
            		}
HXLINE(1616)		bool _hx_tmp;
HXDLIN(1616)		if ((mapIndex >= 0)) {
HXLINE(1616)			_hx_tmp = (mapIndex < this->_data->length);
            		}
            		else {
HXLINE(1616)			_hx_tmp = false;
            		}
HXDLIN(1616)		if (_hx_tmp) {
HXLINE(1616)			int _hx_tmp1;
HXDLIN(1616)			bool _hx_tmp2;
HXDLIN(1616)			if ((mapIndex >= 0)) {
HXLINE(1616)				_hx_tmp2 = (mapIndex < this->_data->length);
            			}
            			else {
HXLINE(1616)				_hx_tmp2 = false;
            			}
HXDLIN(1616)			if (_hx_tmp2) {
HXLINE(1616)				_hx_tmp1 = this->_data->__get(mapIndex);
            			}
            			else {
HXLINE(1616)				_hx_tmp1 = -1;
            			}
HXDLIN(1616)			return ((( ( ::flixel::FlxObject)(this->_tileObjects->__get(_hx_tmp1)) )->allowCollisions & 4369) > 0);
            		}
            		else {
HXLINE(1616)			return false;
            		}
HXDLIN(1616)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,tileAtPointAllowsCollisions,return )

 ::flixel::math::FlxRect FlxBaseTilemap_obj::getBounds( ::flixel::math::FlxRect bounds){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1626_getBounds)
HXLINE(1627)		if (::hx::IsNull( bounds )) {
HXLINE(1628)			 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN(1628)			_this->x = ( (Float)(0) );
HXDLIN(1628)			_this->y = ( (Float)(0) );
HXDLIN(1628)			_this->width = ( (Float)(0) );
HXDLIN(1628)			_this->height = ( (Float)(0) );
HXDLIN(1628)			 ::flixel::math::FlxRect rect = _this;
HXDLIN(1628)			rect->_inPool = false;
HXDLIN(1628)			bounds = rect;
            		}
HXLINE(1630)		Float X = this->x;
HXDLIN(1630)		Float Y = this->y;
HXDLIN(1630)		Float Width = this->get_width();
HXDLIN(1630)		Float Height = this->get_height();
HXDLIN(1630)		bounds->x = X;
HXDLIN(1630)		bounds->y = Y;
HXDLIN(1630)		bounds->width = Width;
HXDLIN(1630)		bounds->height = Height;
HXDLIN(1630)		return bounds;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,getBounds,return )

::Array< int > FlxBaseTilemap_obj::offsetAutoTile;

 ::flixel::path::FlxDiagonalPathfinder FlxBaseTilemap_obj::diagonalPathfinder;


::hx::ObjectPtr< FlxBaseTilemap_obj > FlxBaseTilemap_obj::__new() {
	::hx::ObjectPtr< FlxBaseTilemap_obj > __this = new FlxBaseTilemap_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< FlxBaseTilemap_obj > FlxBaseTilemap_obj::__alloc(::hx::Ctx *_hx_ctx) {
	FlxBaseTilemap_obj *__this = (FlxBaseTilemap_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FlxBaseTilemap_obj), true, "flixel.tile.FlxBaseTilemap"));
	*(void **)__this = FlxBaseTilemap_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

FlxBaseTilemap_obj::FlxBaseTilemap_obj()
{
}

void FlxBaseTilemap_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxBaseTilemap);
	HX_MARK_MEMBER_NAME(_hx_auto,"auto");
	HX_MARK_MEMBER_NAME(widthInTiles,"widthInTiles");
	HX_MARK_MEMBER_NAME(heightInTiles,"heightInTiles");
	HX_MARK_MEMBER_NAME(totalTiles,"totalTiles");
	HX_MARK_MEMBER_NAME(customTileRemap,"customTileRemap");
	HX_MARK_MEMBER_NAME(_randomIndices,"_randomIndices");
	HX_MARK_MEMBER_NAME(_randomChoices,"_randomChoices");
	HX_MARK_MEMBER_NAME(_randomLambda,"_randomLambda");
	HX_MARK_MEMBER_NAME(_tileObjects,"_tileObjects");
	HX_MARK_MEMBER_NAME(_startingIndex,"_startingIndex");
	HX_MARK_MEMBER_NAME(_data,"_data");
	HX_MARK_MEMBER_NAME(_drawIndex,"_drawIndex");
	HX_MARK_MEMBER_NAME(_collideIndex,"_collideIndex");
	 ::flixel::FlxObject_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void FlxBaseTilemap_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_hx_auto,"auto");
	HX_VISIT_MEMBER_NAME(widthInTiles,"widthInTiles");
	HX_VISIT_MEMBER_NAME(heightInTiles,"heightInTiles");
	HX_VISIT_MEMBER_NAME(totalTiles,"totalTiles");
	HX_VISIT_MEMBER_NAME(customTileRemap,"customTileRemap");
	HX_VISIT_MEMBER_NAME(_randomIndices,"_randomIndices");
	HX_VISIT_MEMBER_NAME(_randomChoices,"_randomChoices");
	HX_VISIT_MEMBER_NAME(_randomLambda,"_randomLambda");
	HX_VISIT_MEMBER_NAME(_tileObjects,"_tileObjects");
	HX_VISIT_MEMBER_NAME(_startingIndex,"_startingIndex");
	HX_VISIT_MEMBER_NAME(_data,"_data");
	HX_VISIT_MEMBER_NAME(_drawIndex,"_drawIndex");
	HX_VISIT_MEMBER_NAME(_collideIndex,"_collideIndex");
	 ::flixel::FlxObject_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val FlxBaseTilemap_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"ray") ) { return ::hx::Val( ray_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"auto") ) { return ::hx::Val( _hx_auto ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"_data") ) { return ::hx::Val( _data ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"getRow") ) { return ::hx::Val( getRow_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"rayStep") ) { return ::hx::Val( rayStep_dyn() ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		if (HX_FIELD_EQ(inName,"getTile") ) { return ::hx::Val( getTile_dyn() ); }
		if (HX_FIELD_EQ(inName,"setTile") ) { return ::hx::Val( setTile_dyn() ); }
		if (HX_FIELD_EQ(inName,"getData") ) { return ::hx::Val( getData_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"getRowAt") ) { return ::hx::Val( getRowAt_dyn() ); }
		if (HX_FIELD_EQ(inName,"setDirty") ) { return ::hx::Val( setDirty_dyn() ); }
		if (HX_FIELD_EQ(inName,"autoTile") ) { return ::hx::Val( autoTile_dyn() ); }
		if (HX_FIELD_EQ(inName,"findPath") ) { return ::hx::Val( findPath_dyn() ); }
		if (HX_FIELD_EQ(inName,"overlaps") ) { return ::hx::Val( overlaps_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"updateMap") ) { return ::hx::Val( updateMap_dyn() ); }
		if (HX_FIELD_EQ(inName,"getRowPos") ) { return ::hx::Val( getRowPos_dyn() ); }
		if (HX_FIELD_EQ(inName,"getColumn") ) { return ::hx::Val( getColumn_dyn() ); }
		if (HX_FIELD_EQ(inName,"getBounds") ) { return ::hx::Val( getBounds_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"totalTiles") ) { return ::hx::Val( totalTiles ); }
		if (HX_FIELD_EQ(inName,"_drawIndex") ) { return ::hx::Val( _drawIndex ); }
		if (HX_FIELD_EQ(inName,"updateTile") ) { return ::hx::Val( updateTile_dyn() ); }
		if (HX_FIELD_EQ(inName,"overlapsAt") ) { return ::hx::Val( overlapsAt_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"getColumnAt") ) { return ::hx::Val( getColumnAt_dyn() ); }
		if (HX_FIELD_EQ(inName,"calcRayExit") ) { return ::hx::Val( calcRayExit_dyn() ); }
		if (HX_FIELD_EQ(inName,"rowExistsAt") ) { return ::hx::Val( rowExistsAt_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"widthInTiles") ) { return ::hx::Val( widthInTiles ); }
		if (HX_FIELD_EQ(inName,"_tileObjects") ) { return ::hx::Val( _tileObjects ); }
		if (HX_FIELD_EQ(inName,"getColumnPos") ) { return ::hx::Val( getColumnPos_dyn() ); }
		if (HX_FIELD_EQ(inName,"calcRayEntry") ) { return ::hx::Val( calcRayEntry_dyn() ); }
		if (HX_FIELD_EQ(inName,"autoTileFull") ) { return ::hx::Val( autoTileFull_dyn() ); }
		if (HX_FIELD_EQ(inName,"tileExistsAt") ) { return ::hx::Val( tileExistsAt_dyn() ); }
		if (HX_FIELD_EQ(inName,"getTilePosAt") ) { return ::hx::Val( getTilePosAt_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"heightInTiles") ) { return ::hx::Val( heightInTiles ); }
		if (HX_FIELD_EQ(inName,"_randomLambda") ) { return ::hx::Val( _randomLambda ); }
		if (HX_FIELD_EQ(inName,"_collideIndex") ) { return ::hx::Val( _collideIndex ); }
		if (HX_FIELD_EQ(inName,"cacheGraphics") ) { return ::hx::Val( cacheGraphics_dyn() ); }
		if (HX_FIELD_EQ(inName,"loadMapHelper") ) { return ::hx::Val( loadMapHelper_dyn() ); }
		if (HX_FIELD_EQ(inName,"applyAutoTile") ) { return ::hx::Val( applyAutoTile_dyn() ); }
		if (HX_FIELD_EQ(inName,"getMapIndexAt") ) { return ::hx::Val( getMapIndexAt_dyn() ); }
		if (HX_FIELD_EQ(inName,"getAllTilePos") ) { return ::hx::Val( getAllTilePos_dyn() ); }
		if (HX_FIELD_EQ(inName,"setTileHelper") ) { return ::hx::Val( setTileHelper_dyn() ); }
		if (HX_FIELD_EQ(inName,"overlapsPoint") ) { return ::hx::Val( overlapsPoint_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"_randomIndices") ) { return ::hx::Val( _randomIndices ); }
		if (HX_FIELD_EQ(inName,"_randomChoices") ) { return ::hx::Val( _randomChoices ); }
		if (HX_FIELD_EQ(inName,"_startingIndex") ) { return ::hx::Val( _startingIndex ); }
		if (HX_FIELD_EQ(inName,"loadMapFromCSV") ) { return ::hx::Val( loadMapFromCSV_dyn() ); }
		if (HX_FIELD_EQ(inName,"columnExistsAt") ) { return ::hx::Val( columnExistsAt_dyn() ); }
		if (HX_FIELD_EQ(inName,"getTileIndexAt") ) { return ::hx::Val( getTileIndexAt_dyn() ); }
		if (HX_FIELD_EQ(inName,"getTileByIndex") ) { return ::hx::Val( getTileByIndex_dyn() ); }
		if (HX_FIELD_EQ(inName,"setTileIndexAt") ) { return ::hx::Val( setTileIndexAt_dyn() ); }
		if (HX_FIELD_EQ(inName,"setTileByIndex") ) { return ::hx::Val( setTileByIndex_dyn() ); }
		if (HX_FIELD_EQ(inName,"findPathCustom") ) { return ::hx::Val( findPathCustom_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"customTileRemap") ) { return ::hx::Val( customTileRemap ); }
		if (HX_FIELD_EQ(inName,"initTileObjects") ) { return ::hx::Val( initTileObjects_dyn() ); }
		if (HX_FIELD_EQ(inName,"postGraphicLoad") ) { return ::hx::Val( postGraphicLoad_dyn() ); }
		if (HX_FIELD_EQ(inName,"forEachMapIndex") ) { return ::hx::Val( forEachMapIndex_dyn() ); }
		if (HX_FIELD_EQ(inName,"computePathData") ) { return ::hx::Val( computePathData_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"loadMapFromArray") ) { return ::hx::Val( loadMapFromArray_dyn() ); }
		if (HX_FIELD_EQ(inName,"applyCustomRemap") ) { return ::hx::Val( applyCustomRemap_dyn() ); }
		if (HX_FIELD_EQ(inName,"randomizeIndices") ) { return ::hx::Val( randomizeIndices_dyn() ); }
		if (HX_FIELD_EQ(inName,"getTileInstances") ) { return ::hx::Val( getTileInstances_dyn() ); }
		if (HX_FIELD_EQ(inName,"getAllMapIndices") ) { return ::hx::Val( getAllMapIndices_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"computeDimensions") ) { return ::hx::Val( computeDimensions_dyn() ); }
		if (HX_FIELD_EQ(inName,"isOverlappingTile") ) { return ::hx::Val( isOverlappingTile_dyn() ); }
		if (HX_FIELD_EQ(inName,"getTileCollisions") ) { return ::hx::Val( getTileCollisions_dyn() ); }
		if (HX_FIELD_EQ(inName,"setTileProperties") ) { return ::hx::Val( setTileProperties_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"loadMapFrom2DArray") ) { return ::hx::Val( loadMapFrom2DArray_dyn() ); }
		if (HX_FIELD_EQ(inName,"loadMapFromGraphic") ) { return ::hx::Val( loadMapFromGraphic_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"objectOverlapsTiles") ) { return ::hx::Val( objectOverlapsTiles_dyn() ); }
		if (HX_FIELD_EQ(inName,"computePathDistance") ) { return ::hx::Val( computePathDistance_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"getTileIndexByCoords") ) { return ::hx::Val( getTileIndexByCoords_dyn() ); }
		if (HX_FIELD_EQ(inName,"getTileCoordsByIndex") ) { return ::hx::Val( getTileCoordsByIndex_dyn() ); }
		if (HX_FIELD_EQ(inName,"overlapsWithCallback") ) { return ::hx::Val( overlapsWithCallback_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"setCustomTileMappings") ) { return ::hx::Val( setCustomTileMappings_dyn() ); }
		if (HX_FIELD_EQ(inName,"getDiagonalPathfinder") ) { return ::hx::Val( getDiagonalPathfinder_dyn() ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"forEachOverlappingTile") ) { return ::hx::Val( forEachOverlappingTile_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateTileWithAutoTile") ) { return ::hx::Val( updateTileWithAutoTile_dyn() ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"tilemapOverlapsCallback") ) { return ::hx::Val( tilemapOverlapsCallback_dyn() ); }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"tilemapOverlapsAtCallback") ) { return ::hx::Val( tilemapOverlapsAtCallback_dyn() ); }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"tileAtPointAllowsCollisions") ) { return ::hx::Val( tileAtPointAllowsCollisions_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool FlxBaseTilemap_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 14:
		if (HX_FIELD_EQ(inName,"offsetAutoTile") ) { outValue = ( offsetAutoTile ); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"diagonalPathfinder") ) { outValue = ( diagonalPathfinder ); return true; }
	}
	return false;
}

::hx::Val FlxBaseTilemap_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"auto") ) { _hx_auto=inValue.Cast<  ::flixel::tile::FlxTilemapAutoTiling >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"_data") ) { _data=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"totalTiles") ) { totalTiles=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_drawIndex") ) { _drawIndex=inValue.Cast< int >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"widthInTiles") ) { widthInTiles=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_tileObjects") ) { _tileObjects=inValue.Cast< ::cpp::VirtualArray >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"heightInTiles") ) { heightInTiles=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_randomLambda") ) { _randomLambda=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_collideIndex") ) { _collideIndex=inValue.Cast< int >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"_randomIndices") ) { _randomIndices=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_randomChoices") ) { _randomChoices=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_startingIndex") ) { _startingIndex=inValue.Cast< int >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"customTileRemap") ) { customTileRemap=inValue.Cast< ::Array< int > >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool FlxBaseTilemap_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 14:
		if (HX_FIELD_EQ(inName,"offsetAutoTile") ) { offsetAutoTile=ioValue.Cast< ::Array< int > >(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"diagonalPathfinder") ) { diagonalPathfinder=ioValue.Cast<  ::flixel::path::FlxDiagonalPathfinder >(); return true; }
	}
	return false;
}

void FlxBaseTilemap_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("auto",6f,df,76,40));
	outFields->push(HX_("widthInTiles",fa,b1,71,d4));
	outFields->push(HX_("heightInTiles",39,ce,1a,97));
	outFields->push(HX_("totalTiles",21,f3,d5,16));
	outFields->push(HX_("customTileRemap",ca,70,d3,8a));
	outFields->push(HX_("_randomIndices",a5,d3,07,36));
	outFields->push(HX_("_randomChoices",70,42,cb,2b));
	outFields->push(HX_("_tileObjects",47,55,bd,87));
	outFields->push(HX_("_startingIndex",73,a1,49,3d));
	outFields->push(HX_("_data",09,72,74,f5));
	outFields->push(HX_("_drawIndex",2f,4c,c2,e1));
	outFields->push(HX_("_collideIndex",93,05,8a,b4));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo FlxBaseTilemap_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::tile::FlxTilemapAutoTiling */ ,(int)offsetof(FlxBaseTilemap_obj,_hx_auto),HX_("auto",6f,df,76,40)},
	{::hx::fsInt,(int)offsetof(FlxBaseTilemap_obj,widthInTiles),HX_("widthInTiles",fa,b1,71,d4)},
	{::hx::fsInt,(int)offsetof(FlxBaseTilemap_obj,heightInTiles),HX_("heightInTiles",39,ce,1a,97)},
	{::hx::fsInt,(int)offsetof(FlxBaseTilemap_obj,totalTiles),HX_("totalTiles",21,f3,d5,16)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(FlxBaseTilemap_obj,customTileRemap),HX_("customTileRemap",ca,70,d3,8a)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(FlxBaseTilemap_obj,_randomIndices),HX_("_randomIndices",a5,d3,07,36)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(FlxBaseTilemap_obj,_randomChoices),HX_("_randomChoices",70,42,cb,2b)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(FlxBaseTilemap_obj,_randomLambda),HX_("_randomLambda",49,40,18,0b)},
	{::hx::fsObject /* ::cpp::VirtualArray */ ,(int)offsetof(FlxBaseTilemap_obj,_tileObjects),HX_("_tileObjects",47,55,bd,87)},
	{::hx::fsInt,(int)offsetof(FlxBaseTilemap_obj,_startingIndex),HX_("_startingIndex",73,a1,49,3d)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(FlxBaseTilemap_obj,_data),HX_("_data",09,72,74,f5)},
	{::hx::fsInt,(int)offsetof(FlxBaseTilemap_obj,_drawIndex),HX_("_drawIndex",2f,4c,c2,e1)},
	{::hx::fsInt,(int)offsetof(FlxBaseTilemap_obj,_collideIndex),HX_("_collideIndex",93,05,8a,b4)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo FlxBaseTilemap_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /* ::Array< int > */ ,(void *) &FlxBaseTilemap_obj::offsetAutoTile,HX_("offsetAutoTile",f0,58,a2,c6)},
	{::hx::fsObject /*  ::flixel::path::FlxDiagonalPathfinder */ ,(void *) &FlxBaseTilemap_obj::diagonalPathfinder,HX_("diagonalPathfinder",a0,c5,8f,53)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String FlxBaseTilemap_obj_sMemberFields[] = {
	HX_("auto",6f,df,76,40),
	HX_("widthInTiles",fa,b1,71,d4),
	HX_("heightInTiles",39,ce,1a,97),
	HX_("totalTiles",21,f3,d5,16),
	HX_("customTileRemap",ca,70,d3,8a),
	HX_("_randomIndices",a5,d3,07,36),
	HX_("_randomChoices",70,42,cb,2b),
	HX_("_randomLambda",49,40,18,0b),
	HX_("_tileObjects",47,55,bd,87),
	HX_("_startingIndex",73,a1,49,3d),
	HX_("_data",09,72,74,f5),
	HX_("_drawIndex",2f,4c,c2,e1),
	HX_("_collideIndex",93,05,8a,b4),
	HX_("updateTile",d7,b5,b1,05),
	HX_("cacheGraphics",2d,61,95,fc),
	HX_("initTileObjects",16,be,45,2e),
	HX_("updateMap",13,e8,df,82),
	HX_("computeDimensions",a4,a4,eb,f3),
	HX_("getColumnAt",1f,2c,11,21),
	HX_("getRowAt",37,65,3e,4d),
	HX_("getColumnPos",e8,cc,00,ce),
	HX_("getRowPos",d0,88,65,49),
	HX_("getTileIndexByCoords",03,79,8b,76),
	HX_("getTileCoordsByIndex",b9,63,25,a1),
	HX_("ray",ea,d5,56,00),
	HX_("rayStep",56,26,de,2f),
	HX_("calcRayEntry",dd,53,c1,6c),
	HX_("calcRayExit",13,b2,86,c2),
	HX_("isOverlappingTile",7d,50,c6,cb),
	HX_("forEachOverlappingTile",bd,fa,b5,d8),
	HX_("overlapsWithCallback",17,c3,72,a8),
	HX_("objectOverlapsTiles",9a,54,0e,a5),
	HX_("setDirty",10,b9,04,e8),
	HX_("destroy",fa,2c,86,24),
	HX_("loadMapFromCSV",06,2b,38,8f),
	HX_("loadMapFromArray",d9,80,a3,db),
	HX_("loadMapFrom2DArray",c7,d3,90,ac),
	HX_("loadMapFromGraphic",e8,bd,b6,e5),
	HX_("loadMapHelper",24,aa,93,69),
	HX_("postGraphicLoad",6e,44,44,1d),
	HX_("applyAutoTile",cb,19,58,70),
	HX_("applyCustomRemap",8a,6c,0c,b4),
	HX_("randomizeIndices",f6,8d,4c,14),
	HX_("autoTile",3d,ba,22,30),
	HX_("autoTileFull",6c,32,17,bf),
	HX_("setCustomTileMappings",86,00,11,09),
	HX_("getMapIndexAt",9f,81,c2,dd),
	HX_("getColumn",0c,d8,e1,42),
	HX_("getRow",24,1b,26,a3),
	HX_("tileExistsAt",3d,eb,da,66),
	HX_("columnExistsAt",e5,56,91,15),
	HX_("rowExistsAt",29,ce,c7,39),
	HX_("getTileIndexAt",21,ce,c1,07),
	HX_("getTilePosAt",23,1e,49,61),
	HX_("getAllTilePos",1b,5c,94,6a),
	HX_("getTile",e4,7a,7f,1f),
	HX_("getTileByIndex",37,bb,aa,c4),
	HX_("getTileCollisions",c5,3f,3d,c8),
	HX_("getTileInstances",ba,6b,01,25),
	HX_("getAllMapIndices",f6,e9,3d,6d),
	HX_("forEachMapIndex",a0,aa,e7,7f),
	HX_("setTileIndexAt",95,b6,e1,27),
	HX_("setTile",f0,0b,81,12),
	HX_("setTileByIndex",ab,a3,ca,e4),
	HX_("setTileHelper",7e,91,5d,0a),
	HX_("updateTileWithAutoTile",da,4a,84,09),
	HX_("setTileProperties",03,58,a1,54),
	HX_("getData",e0,05,e6,14),
	HX_("findPath",7e,f2,e5,9c),
	HX_("findPathCustom",cf,e0,9e,0c),
	HX_("computePathDistance",11,4c,56,20),
	HX_("computePathData",06,71,83,cf),
	HX_("getDiagonalPathfinder",d6,47,aa,b2),
	HX_("overlaps",0c,d3,2a,45),
	HX_("tilemapOverlapsCallback",3f,9d,f8,ac),
	HX_("overlapsAt",1f,e7,ce,03),
	HX_("tilemapOverlapsAtCallback",d2,ab,68,db),
	HX_("overlapsPoint",a4,c5,bd,35),
	HX_("tileAtPointAllowsCollisions",1a,5b,2f,f6),
	HX_("getBounds",ab,0f,74,e2),
	::String(null()) };

static void FlxBaseTilemap_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxBaseTilemap_obj::offsetAutoTile,"offsetAutoTile");
	HX_MARK_MEMBER_NAME(FlxBaseTilemap_obj::diagonalPathfinder,"diagonalPathfinder");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxBaseTilemap_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxBaseTilemap_obj::offsetAutoTile,"offsetAutoTile");
	HX_VISIT_MEMBER_NAME(FlxBaseTilemap_obj::diagonalPathfinder,"diagonalPathfinder");
};

#endif

::hx::Class FlxBaseTilemap_obj::__mClass;

static ::String FlxBaseTilemap_obj_sStaticFields[] = {
	HX_("offsetAutoTile",f0,58,a2,c6),
	HX_("diagonalPathfinder",a0,c5,8f,53),
	::String(null())
};

void FlxBaseTilemap_obj::__register()
{
	FlxBaseTilemap_obj _hx_dummy;
	FlxBaseTilemap_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flixel.tile.FlxBaseTilemap",19,d7,a6,6a);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxBaseTilemap_obj::__GetStatic;
	__mClass->mSetStaticField = &FlxBaseTilemap_obj::__SetStatic;
	__mClass->mMarkFunc = FlxBaseTilemap_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(FlxBaseTilemap_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FlxBaseTilemap_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FlxBaseTilemap_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxBaseTilemap_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxBaseTilemap_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxBaseTilemap_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FlxBaseTilemap_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_26_boot)
HXDLIN(  26)		offsetAutoTile = ::Array_obj< int >::fromData( _hx_array_data_6aa6d719_88,256);
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_36d94048d9e4941f_45_boot)
HXDLIN(  45)		diagonalPathfinder =  ::flixel::path::FlxDiagonalPathfinder_obj::__alloc( HX_CTX ,null());
            	}
}

} // end namespace flixel
} // end namespace tile
